concrete TestProgram {
  @type run () -> ()
}

define TestProgram {
  $ReadOnlyExcept[]$

  @category String testProgram <- $ExprLookup[MODULE_PATH]$ + "/test.sh"

  run () {
    if (Argv.global().size() < 2 || Argv.global().size() > 3) {
      fail(Argv.global().readAt(0) + " \"async\" | (\"small\"||[size]) (count)")
    }

    if (Argv.global().readAt(1) == "async") {
      \ runAsyncTest()
    } else {
      \ runGraphTest()
    }
  }

  @type constructCall (Float,String,Int) -> (ChainCommand<AsyncId>)
  constructCall (delay,message,status) {
    return `ChainCommand:asyncRun<AsyncId>` Command.buildFor(testProgram)
      .addArg(delay)
      .addArg(message)
      .addArg(status)
      .build()
  }

  @type runAsyncTest () -> ()
  runAsyncTest () {
    ChainCommand<AsyncId> exec1 <- constructCall(0.1,"exec1",0)
    ChainCommand<AsyncId> exec2 <- constructCall(0.1,"exec2",0)
    ChainCommand<AsyncId> exec3 <- constructCall(0.1,"exec3",0)
    ChainCommand<AsyncId> exec4 <- constructCall(0.1,"exec4",0).after(exec2).after(exec3)
    ChainCommand<AsyncId> exec5 <- constructCall(0.1,"exec5",0).after(exec2)
    ChainCommand<AsyncId> exec6 <- constructCall(0.1,"exec6",0).after(exec1).after(exec4).after(exec5)

    ErrorOr<Int> status <- exec6 `Compute:with` InlineRunner<AsyncId>.limit(2)

    \ BasicOutput.stderr()
        .write(status.getValue())
        .write("\n")
        .flush()
  }

  @type runGraphTest () -> ()
  runGraphTest () {
    GraphTree<Int> graphTree <- defer
    if (Argv.global().readAt(1) == "small") {
      graphTree <- constructSmall()
    } else {
      graphTree <- `constructLarge` ParseChars.int(Argv.global().readAt(1)).getValue()
    }

    Int count <- 1000
    if (Argv.global().size() >= 3) {
      count <- ParseChars.int(Argv.global().readAt(2)).getValue()
    }

    Generator<Float> random <- RandomUniform.probability().setSeed(Realtime.monoSeconds().asInt())

    traverse (`Counter.zeroIndexed` count -> Int i) {
      scoped {
        optional Int nextId <- empty
        GraphTraverser<Int> traverser <-graphTree.newTraverser(SelectRandomWeighted.with(random))
      } in while (`present` (nextId <- traverser.nextNode())) {
        \ BasicOutput.stdout()
            .write(`require` nextId)
            .write(" ")
            .flush()
      }
      \ BasicOutput.stdout()
          .write("\n")
          .flush()
      \ BasicOutput.stderr()
          .write(i)
          .write("\n")
          .flush()
    }
  }

  @type constructSmall () -> (GraphTree<Int>)
  constructSmall () (graphTree) {
    TestNode node1 <- TestNode.new(1,Vector<TestNode>.new())
    TestNode node2 <- TestNode.new(2,Vector<TestNode>.new())
    TestNode node3 <- TestNode.new(3,Vector<TestNode>.new()
        .append(node1)
        .append(node2))
    TestNode node4 <- TestNode.new(4,Vector<TestNode>.new()
        .append(node1)
        .append(node3))
    TestNode node5 <- TestNode.new(5,Vector<TestNode>.new()
        .append(node1))
    TestNode node6 <- TestNode.new(6,Vector<TestNode>.new())
    TestNode node7 <- TestNode.new(7,Vector<TestNode>.new()
        .append(node6))
    TestNode node8 <- TestNode.new(8,Vector<TestNode>.new())

    Vector<TestNode> allNodes <- Vector<TestNode>.new()
        .append(node1)
        .append(node2)
        .append(node3)
        .append(node4)
        .append(node5)
        .append(node6)
        .append(node7)
        .append(node8)

    graphTree <- GraphTree<Int>.new(
        `DualGraph:from` allNodes `ComputeBlockers.with` BlockWithAll<Int>.new())
  }

  @type constructLarge (Int) -> (GraphTree<Int>)
  constructLarge (size) (graphTree) {
    Vector<TestNode> allNodes <- Vector<TestNode>.new()
    traverse (Counter.zeroIndexed(size) -> Int id) {
      \ allNodes.append(TestNode.new(id,allNodes.duplicate()))
    }
    graphTree <- GraphTree<Int>.new(
        `DualGraph:from` allNodes `ComputeBlockers.with` BlockWithAll<Int>.new())
  }
}

concrete TestNode {
  refines GraphNode<Int>

  @type new (Int,DefaultOrder<TestNode>) -> (#self)
}

define TestNode {
  $ReadOnly[id,outgoing]$

  @value Int id
  @value DefaultOrder<TestNode> outgoing

  new (id,outgoing) {
    return #self{ id, outgoing }
  }

  getId () {
    return id
  }

  outgoing () {
    return outgoing
  }
}
