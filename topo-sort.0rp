$ModuleOnly$

@value interface GraphNode<|#id> {
  getId () -> (#id)
  outgoing () -> (ReadAt<#self>)
}

// Example:
//
//   GraphQueue<#n> queue <- ...
//
//   scoped {
//     optional #n node <- empty
//   } cleanup {
//     // General safeguard in case there's a return or break in the loop.
//     \ queue.finish(node)
//   } in while (`present` (node <- queue.exchange(node))) {
//     // Process node.
//   }
@value interface GraphQueue<#n> {
  isEmpty () -> (Bool)
  finish (optional #n) -> ()
  exchange (optional #n) -> (optional #n)
}

@value interface BlockingGraphQueue<#n> {
  refines GraphQueue<#n>

  timedExchange (optional #n,Float) -> (optional #n)
}

concrete TopoSort<#n,#id> {
  refines LessThan2<#n>
  #id immutable
  #id defines LessThan<#id>
  #n requires GraphNode<#id>

  // Notes:
  // - All input nodes *must* have unique IDs.
  // - The input does not need to include all nodes in the graph; however, the
  //   entire graph reachable from the input nodes will be processed.
  // - An outgoing edge is treated as a dependency relationship.
  // - Storage space is O(n^2).
  // - Construction complexity is O(n^2 log n).
  @category relationFrom<#n,#id>
    #id immutable
    #id defines LessThan<#id>
    #n requires GraphNode<#id>
  (ReadAt<#n>) -> (TopoSort<#n,#id>)

  // Notes:
  // - The input does not need to include all nodes in the graph. All nodes that
  //   are reachable from the provided nodes will be added to the queue.
  // - Storage space is O(n^2).
  // - Construction complexity is O(n^2 log n).
  @value graphQueue (ReadAt<#id>,Generator<Float>) -> (BlockingGraphQueue<#n>)

  // Notes:
  // - The input does not need to include all nodes in the graph.
  // - Complexity is O(n^2 log n).
  @value isSorted (ReadAt<#n>) -> (Bool)
}
