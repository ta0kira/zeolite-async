$ModuleOnly$

@value interface GraphNode<|#id> {
  getId () -> (#id)
  outgoing () -> (ReadAt<#self>)
}

@value interface GraphQueue<#n> {
  isEmpty () -> (Bool)
  finish (optional #n) -> ()
  exchange (optional #n) -> (optional #n)
}

concrete TopoSort<#n,#id> {
  refines LessThan2<#n>
  #id immutable
  #id defines LessThan<#id>
  #n requires GraphNode<#id>

  // Notes:
  // - All input nodes *must* have unique IDs.
  // - The input does not need to include all nodes in the graph; however, the
  //   entire graph reachable from the input nodes will be processed.
  // - An outgoing edge is treated as a dependency relationship.
  @category relationFrom<#n,#id>
    #id immutable
    #id defines LessThan<#id>
    #n requires GraphNode<#id>
  (ReadAt<#n>) -> (TopoSort<#n,#id>)

  // Notes:
  // - All input nodes *must* have unique IDs.
  // - The input does not need to include all nodes in the graph. Only nodes
  //   included in the input will be used, even if others are reachable.
  @value graphQueue (ReadAt<#n>,Generator<Float>) -> (GraphQueue<#n>)

  // Notes:
  // - The input does not need to include all nodes in the graph.
  @value isSorted (ReadAt<#n>) -> (Bool)
}
