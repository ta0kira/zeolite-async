testcase "AsyncExec tests" {
  success
  timeout 5
}

unittest success {
  AsyncExec command <- "/bin/true" `AsyncExec.withArgs` empty
  \ command.start().finish()
  \ UtilTesting.checkSuccess(command.get(),0)
}

unittest collect {
  AsyncExec command <- "/bin/true" `AsyncExec.withArgs` empty
  TestCollector collector <- TestCollector.new()
  \ command.collect(collector)
  [Container&SetReader<AsyncId>] results <- collector.results()
  \ Testing.checkEquals(results.size(),1)
  \ Testing.checkTrue(results.member(command.getId()))
}

unittest tryFinish {
  AsyncExec command <- "/bin/sleep" `AsyncExec.withArgs` Vector<Float>.new().append(0.5)
  \ command.start()
  Bool pending <- false
  while (!command.tryFinish()) {
    pending <- true
  }
  \ UtilTesting.checkSuccess(command.get(),0)
}

unittest idempotent {
  AsyncExec command <- "/bin/true" `AsyncExec.withArgs` empty
  \ command.start().start().finish().finish()
  \ UtilTesting.checkSuccess(command.get(),0)
}

unittest failure {
  AsyncExec command <- "/bin/false" `AsyncExec.withArgs` empty
  \ command.start().finish()
  \ UtilTesting.checkSuccessBetween(command.get(),0,256)
}

unittest badBinary {
  AsyncExec command <- "/path/to/bad" `AsyncExec.withArgs` empty
  \ command.start().finish()
  \ UtilTesting.checkSuccessBetween(command.get(),0,256)
}

concrete TestCollector {
  refines AsyncCollector<AsyncId>

  @type new () -> (TestCollector)
  @value results () -> ([Container&SetReader<AsyncId>])
}

define TestCollector {
  @value HashedSet<AsyncId> added

  new () {
    return TestCollector{ HashedSet<AsyncId>.new() }
  }

  include (node,_) {
    \ added.add(node.getId())
    return self
  }

  results () {
    return added
  }
}


testcase "AsyncExec finish without start" {
  crash
  require "started"
}

unittest test {
  AsyncExec command <- "/bin/true" `AsyncExec.withArgs` empty
  \ command.finish()
}


testcase "AsyncExec get without start" {
  crash
  require "started"
}

unittest test {
  AsyncExec command <- "/bin/true" `AsyncExec.withArgs` empty
  \ command.get()
}


testcase "AsyncExec get without finish" {
  crash
  require "completed"
}

unittest test {
  AsyncExec command <- "/bin/true" `AsyncExec.withArgs` empty
  \ command.start().get()
}
