define MergePresorted {
  from (topLevel,children) (output) {
    output <- Vector<#x>.new()
    // Initialize queue:
    // - Keys represent values that are already visible.
    // - Values contain lists of iterators for the next items in the respective
    //   children lists.
    // NOTE: Some lists might be empty, which is fine. That just means that when
    // the value is processed, nothing follows it in any children.
    SortedMap<#x,Vector<Order<#x>>> queue <- SortedMap<#x,Vector<Order<#x>>>.new()
    traverse (topLevel.defaultOrder() -> #x value) {
      if (! `present` queue.get(value)) {
        \ value `queue.set` Vector<Order<#x>>.new()
      }
    }
    $Hidden[topLevel]$
    traverse (children.defaultOrder() -> DefaultOrder<#x> values) {
      scoped {
        optional Order<#x> first <- values.defaultOrder()
      } in if (`present` first) {
        \ `require` first `addTo` queue
      }
    }
    $Hidden[children]$
    // Algorithm:
    // 1. Remove the lowest entry and append it to the output.
    // 2. Iterate the nexts.
    //    a. Make sure it exists in the queue.
    //    b. If it has its own next, add that to the corresponding nexts.
    while (queue.size() > 0) {
      #x nextValue <- require(queue.defaultOrder()).get().getKey()
      DefaultOrder<Order<#x>> nexts <- require(nextValue `queue.swap` empty)
      \ output.append(nextValue)
      $Hidden[nextValue]$
      traverse (nexts.defaultOrder() -> Order<#x> oldNext) {
        \ oldNext `addTo` queue
      }
    }
  }

  @category addTo<#x> (Order<#x>,SortedMap<#x,Vector<Order<#x>>>) -> ()
  addTo (iterator,queue) {
    #x value <- iterator.get()
    optional Order<#x> next <- iterator.next()
    if (! `present` queue.get(value)) {
      \ value `queue.set` Vector<Order<#x>>.new()
    }
    if (`present` next) {
      \ require(queue.get(value)).append(`require` next)
    }
  }
}
