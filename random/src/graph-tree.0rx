define GraphTree {
  $ReadOnlyExcept[]$

  @value DefaultOrder<KeyValue<#id,DefaultOrder<#id>>> blockedBy
  @value KVReader<#id,DefaultOrder<#id>> blockers

  new (blockedBy,blockers) {
    return #self{ blockedBy, blockers }
  }

  newTraverser (selector) {
    return GraphTreeTraverser<#id>.new(blockedBy,blockers,selector)
  }
}

concrete GraphTreeTraverser<#id> {
  refines GraphTraverser<#id>

  #id immutable
  #id requires Hashed
  #id defines Equals<#id>

  @type new (DefaultOrder<KeyValue<#id,DefaultOrder<#id>>>,KVReader<#id,DefaultOrder<#id>>,IndexSelector) -> (#self)
}

define GraphTreeTraverser {
  $ReadOnlyExcept[]$

  refines GraphTraverser<#id>

  @value HashedSet<#id> candidates
  @value HashedMap<#id,Int> refCounts
  @value HashedMap<#id,HashedSet<#id>> blockedBy
  @value KVReader<#id,DefaultOrder<#id>> blockers
  @value IndexSelector selector

  new (blockedBy,blockers,selector) {
    return #self{
        HashedSet<#id>.new(),
        HashedMap<#id,Int>.new(),
        deepCopyMap(blockedBy),
        blockers,
        selector
    }.setUnblocked()
  }

  nextNode () (node) {
    node <- empty
    if (candidates.size() > 0) {
      if (candidates.size() == 1) {
        // Just use first node if that's the only one.
        node <- nextNodeIs(require(candidates.defaultOrder()).get())
      } else {
        ReadAt<#id> ids, ReadAt<Float> weights <- computeWeights()
        Int index <- `selector.selectFrom` weights
        node <- nextNodeIs(ids.readAt(index))
      }
    }
  }

  @type deepCopyMap (DefaultOrder<KeyValue<#id,DefaultOrder<#id>>>) -> (HashedMap<#id,HashedSet<#id>>)
  deepCopyMap (original) (copy) {
    copy <- HashedMap<#id,HashedSet<#id>>.new()
    traverse (original.defaultOrder() -> KeyValue<#id,DefaultOrder<#id>> keyValue) {
      \ keyValue.getKey() `copy.set` (keyValue.getValue().defaultOrder() `OrderH:copyTo` HashedSet<#id>.new())
    }
  }

  @value setUnblocked () -> (#self)
  setUnblocked () {
    traverse (blockedBy.defaultOrder() -> KeyValue<#id,Container> node) {
      if (node.getValue().size() == 0) {
        \ unblockNode(node.getKey())
      }
    }
    return self
  }

  @value nextNodeIs (#id) -> (#id)
  nextNodeIs (node) {
    \ candidates.remove(node)
    traverse (getBlockers(node) -> #id child) {
      HashedSet<#id> stillBlockedBy <- require(blockedBy.get(child)).remove(node)
      $Hidden[node]$
      if (stillBlockedBy.size() == 0) {
        \ unblockNode(child)
      } else {
        \ decrementRefCount(child)
      }
    }
    return node
  }

  @value unblockNode (#id) -> ()
  unblockNode (node) {
    \ candidates.add(node)
    \ refCounts.remove(node)
    // NOTE: Don't change `blockedBy` here because we might be in a loop.
    traverse (getBlockers(node) -> #id child) {
      $Hidden[node]$
      \ incrementRefCount(child)
    }
  }

  @value incrementRefCount (#id) -> ()
  incrementRefCount (node) {
    scoped {
      optional Int existing <- refCounts.get(node)
    } in if (`present` existing) {
      \ node `refCounts.set` (require(existing)+1)
    } else {
      \ node `refCounts.set` 1
    }
  }

  @value decrementRefCount (#id) -> ()
  decrementRefCount (node) {
    scoped {
      optional Int existing <- refCounts.get(node)
    } in if (`present` existing) {
      \ node `refCounts.set` (require(existing)-1)
    }
  }

  @value computeWeights () -> (ReadAt<#id>,ReadAt<Float>)
  computeWeights () {
    Vector<#id> ids       <- Vector<#id>.new()
    Vector<Float> weights <- Vector<Float>.new()
    traverse (candidates.defaultOrder() -> #id node) {
      Float weight <- 1.0  // One point for the node itself.
      traverse (getBlockers(node) -> #id child) {
        $Hidden[node]$
        // Weights for children divided evenly among candidates.
        weight <- weight+1.0/require(refCounts.get(child)).asFloat()
      }
      \ ids.append(node)
      \ weights.append(weight)
    }
    return ids, weights
  }

  @value getBlockers (#id) -> (optional Order<#id>)
  getBlockers (node) {
    return require(blockers.get(node)).defaultOrder()
  }
}

define SelectRandomWeighted {
  @value Generator<Float> random

  with (random) {
    return #self{ random }
  }

  selectFrom (candidates) {
    Float total <- 0.0
    traverse (Counter.zeroIndexed(candidates.size()) -> Int index) {
      total <- total+candidates.readAt(index)
    }
    Float value <- random.generate()*total
    $Hidden[total]$
    traverse (Counter.zeroIndexed(candidates.size()) -> Int index) {
      if (value < candidates.readAt(index)) {
        return index
      } else {
        value <- value-candidates.readAt(index)
      }
    }
    // In case rounding errors push `value` past the end.
    return candidates.size()-1
  }
}

define SelectRandomUniform {
  @value Generator<Float> random

  with (random) {
    return #self{ random }
  }

  selectFrom (candidates) {
    return (random.generate()*candidates.size().asFloat()).asInt() `Ranges:min` (candidates.size()-1)
  }
}

define SelectMax {
  new () {
    return #self{ }
  }

  selectFrom (candidates) (chosen) {
    chosen <- candidates.size()-1
    Float max <- 0.0
    traverse (Counter.zeroIndexed(candidates.size()) -> Int index) {
      $ReadOnly[index]$
      if (candidates.readAt(index) > max) {
        chosen <- index
        max <- candidates.readAt(index)
      }
    }
  }
}

define BlockWithAll {
  new () {
    return #self{ }
  }

  getChildren (node,blockers) {
    Vector<#id> topLevel <- Vector<#id>.new()
    Vector<DefaultOrder<#id>> children <- Vector<DefaultOrder<#id>>.new()
    traverse (node.outgoing().defaultOrder() -> GraphNode<#id> child) {
      $Hidden[node]$
      \ topLevel.append(child.getId())
      \ children.append(`require` `blockers.get` child.getId())
    }
    return MergePresorted:from(topLevel,children)
  }
}

define BlockWithDirect {
  new () {
    return #self{ }
  }

  getChildren (node,blockers) {
    Vector<#id> children <- Vector<#id>.new()
    traverse (node.outgoing().defaultOrder() -> GraphNode<#id> child) {
      $Hidden[node]$
      \ children.append(child.getId())
    }
    return children
  }
}

define ComputeBlockers {
  with (nodes,policy) (blockedBy,blockers) {
    HashedMap<#id,GraphNode<#id>> idToNode <- HashedMap<#id,GraphNode<#id>>.new()
    blockedBy <- HashedMap<#id,HashedSet<#id>>.new()
    blockers  <- HashedMap<#id,DefaultOrder<#id>>.new()
    traverse (nodes.defaultOrder() -> GraphNode<#id> node) {
      \ node.getId() `idToNode.set` node
      \ setBlockedBy(node,blockedBy)
    }
    traverse (blockedBy.defaultOrder() -> KeyValue<#id,Container> node) {
      if (node.getValue().size() == 0) {
        \ setBlockers(`require` idToNode.get(node.getKey()),policy,blockers)
      }
    }
  }

  @category setBlockedBy<#id>
    #id immutable
    #id requires Hashed
    #id defines Equals<#id>
  (GraphNode<#id>,HashedMap<#id,HashedSet<#id>>) -> ()
  setBlockedBy (node,blockedBy) {
    if (! `present` blockedBy.get(node.getId())) {
      \ node.getId() `blockedBy.set` HashedSet<#id>.new()
    }
    traverse (node.outgoing().defaultOrder() -> GraphNode<#id> child) {
      if (! `present` blockedBy.get(child.getId())) {
        $Hidden[node]$
        \ child.getId() `blockedBy.set` HashedSet<#id>.new()
      }
      \ require(blockedBy.get(child.getId())).add(node.getId())
    }
  }

  @category setBlockers<#id>
    #id immutable
    #id requires Hashed
    #id defines Equals<#id>
  (GraphNode<#id>,BlockerPolicy<GraphNode<#id>,#id>,HashedMap<#id,DefaultOrder<#id>>) -> ()
  setBlockers (node,policy,blockers) {
    if (`present` blockers.get(node.getId())) {
      return _
    }
    // This mitigates potential cycles in the graph.
    \ node.getId() `blockers.set` AlwaysEmpty.default()
    traverse (node.outgoing().defaultOrder() -> GraphNode<#id> child) {
      $Hidden[node]$
      \ setBlockers(child,policy,blockers)
    }
    \ node.getId() `blockers.set` policy.getChildren(node,blockers)
  }


  @category findUnblocked<#id>
    #id immutable
    #id requires Hashed
    #id defines Equals<#id>
  (DefaultOrder<GraphNode<#id>>) -> (Vector<GraphNode<#id>>)
  findUnblocked (nodes) (unblocked) {
    unblocked <- Vector<GraphNode<#id>>.new()
    HashedSet<#id> blocked <- HashedSet<#id>.new()
    traverse (nodes.defaultOrder() -> GraphNode<#id> node) {
      traverse (node.outgoing().defaultOrder() -> GraphNode<#id> child) {
        $Hidden[node]$
        \ blocked.add(child.getId())
      }
    }
    traverse (nodes.defaultOrder() -> GraphNode<#id> node) {
      if (!blocked.member(node.getId())) {
        \ unblocked.append(node)
      }
    }
  }
}

define DualGraph {
  $ReadOnlyExcept[]$

  refines GraphNode<#id>

  @value #id id
  @value Vector<DualGraph<#id>> outgoing

  getId () {
    return id
  }

  outgoing () {
    return outgoing
  }

  from (nodes) {
    HashedMap<#id,DualGraph<#id>> parents <- HashedMap<#id,DualGraph<#id>>.new()
    traverse (nodes.defaultOrder() -> GraphNode<#id> node) {
      \ node `DualGraph<#id>.populateParents` parents
    }
    return parents.valueOrder() `OrderH:copyTo` Vector<DualGraph<#id>>.new()
  }

  @type populateParents (GraphNode<#id>,HashedMap<#id,DualGraph<#id>>) -> ()
  populateParents (node,parents) {
    if (`present` parents.get(node.getId())) {
      return _
    }
    DualGraph<#id> dualNode <- #self{ node.getId(), Vector<DualGraph<#id>>.new() }
    \ node.getId() `parents.set` dualNode
    traverse (node.outgoing().defaultOrder() -> GraphNode<#id> child) {
      \ populateParents(child,parents)
      \ require(parents.get(child.getId())).addParent(dualNode)
    }
  }

  @value addParent (DualGraph<#id>) -> ()
  addParent (parent) {
    \ outgoing.append(parent)
  }
}
