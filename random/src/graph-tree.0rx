define GraphTree {
  @value Vector<#id> output
  @value HashedSet<#id> candidates
  @value HashedMap<#id,Int> refCounts
  @value [KVReader<#id,DefaultOrder<#id>> & DefaultOrder<KeyValue<#id,DefaultOrder<#id>>>] blockers

  randomize (blockers,selector) {
    #self working <- #self{
        Vector<#id>.new(),
        HashedSet<#id>.new(),
        HashedMap<#id,Int>.new(),
        blockers }
    return working.findUnblocked().execute(selector).getOutput()
  }

  @value findUnblocked () -> (#self)
  findUnblocked () {
    HashedSet<#id> blocked <- HashedSet<#id>.new()
    traverse (blockers.defaultOrder() -> KeyValue<any,DefaultOrder<#id>> children) {
      traverse (children.getValue().defaultOrder() -> #id child) {
        \ blocked.add(child)
      }
    }
    traverse (blockers.defaultOrder() -> KeyValue<#id,any> node) {
      if (!blocked.member(node.getKey())) {
        \ unblockNode(node.getKey())
      }
    }
    return self
  }

  @value execute (IndexSelector) -> (#self)
  execute (selector) {
    while (candidates.size() > 0) {
      if (candidates.size() == 1) {
        // Just use first node if that's the only one.
        \ nextNodeIs(require(candidates.defaultOrder()).get())
      } else {
        ReadAt<#id> ids, ReadAt<Float> weights <- computeWeights()
        Int index <- `selector.selectFrom` weights
        \ nextNodeIs(ids.readAt(index))
      }
    }
    return self
  }

  @value nextNodeIs (#id) -> ()
  nextNodeIs (node) {
    \ output.append(node)
    \ candidates.remove(node)
    traverse (getBlockers(node) -> #id child) {
      $Hidden[node]$
      Int newCount <- require(refCounts.get(child))-1
      if (newCount == 0) {
        \ `refCounts.remove` child
        \ unblockNode(child)
      } else {
        \ child `refCounts.set` newCount
      }
    }
  }

  @value unblockNode (#id) -> ()
  unblockNode (node) {
    traverse (getBlockers(node) -> #id child) {
      $Hidden[node]$
      \ incrementRefCount(child)
    }
  }

  @value incrementRefCount (#id) -> ()
  incrementRefCount (node) {
    Int count <- 1
    scoped {
      optional Int existing <- refCounts.get(node)
    } in if (`present` existing) {
      count <- count+require(existing)
    }
    \ node `refCounts.set` count
  }

  @value computeWeights () -> (ReadAt<#id>,ReadAt<Float>)
  computeWeights () {
    Vector<#id> ids       <- Vector<#id>.new()
    Vector<Float> weights <- Vector<Float>.new()
    traverse (candidates.defaultOrder() -> #id node) {
      Float weight <- 1.0  // One point for the node itself.
      traverse (getBlockers(node) -> #id child) {
        $Hidden[node]$
        // Weights for children divided evenly among candidates.
        weight <- weight+1.0/require(refCounts.get(child)).asFloat()
      }
      \ ids.append(node)
      \ weights.append(weight)
    }
    return ids, weights
  }

  @value getBlockers (#id) -> (optional Order<#id>)
  getBlockers (node) {
    return require(blockers.get(node)).defaultOrder()
  }

  @value getOutput () -> (DefaultOrder<#id>)
  getOutput () { return output }
}

define SelectRandom {
  @value Generator<Float> random

  new (random) {
    return #self{ random }
  }

  selectFrom (candidates) {
    Float total <- 0.0
    traverse (Counter.zeroIndexed(candidates.size()) -> Int index) {
      total <- total+candidates.readAt(index)
    }
    Float value <- random.generate()*total
    $Hidden[total]$
    traverse (Counter.zeroIndexed(candidates.size()) -> Int index) {
      if (value < candidates.readAt(index)) {
        return index
      } else {
        value <- value-candidates.readAt(index)
      }
    }
    // In case rounding errors push `value` past the end.
    return candidates.size()-1
  }
}

define BlockWithAll {
  new () {
    return #self{ }
  }

  getChildren (node,blockers) {
    HashedSet<#id> children <- HashedSet<#id>.new()
    traverse (node.outgoing().defaultOrder() -> GraphNode<#id> child) {
      $Hidden[node]$
      scoped {
        optional DefaultOrder<#id> childBlockers <- blockers.get(child.getId())
      } in if (`present` childBlockers) {
        \ require(childBlockers).defaultOrder() `OrderH:copyTo` children
      }
    }
    return children
  }
}

define ComputeBlockers {
  with (nodes,policy) (blockers) {
    blockers <- HashedMap<#id,DefaultOrder<#id>>.new()
    traverse (findUnblocked(nodes).defaultOrder() -> GraphNode<#id> node) {
      \ setBlockers(node,policy,blockers)
    }
  }

  @category setBlockers<#id>
    #id immutable
    #id requires Hashed
    #id defines Equals<#id>
  (GraphNode<#id>,BlockerPolicy<#id,GraphNode<#id>>,HashedMap<#id,DefaultOrder<#id>>) -> ()
  setBlockers (node,policy,blockers) {
    if (`present` blockers.get(node.getId())) {
      return _
    }
    // This mitigates potential cycles in the graph.
    \ node.getId() `blockers.set` AlwaysEmpty.default()
    traverse (node.outgoing().defaultOrder() -> GraphNode<#id> child) {
      $Hidden[node]$
      \ setBlockers(child,policy,blockers)
    }
    \ node.getId() `blockers.set` policy.getChildren(node,blockers)
  }


  @category findUnblocked<#id>
    #id immutable
    #id requires Hashed
    #id defines Equals<#id>
  (DefaultOrder<GraphNode<#id>>) -> (Vector<GraphNode<#id>>)
  findUnblocked (nodes) (unblocked) {
    unblocked <- Vector<GraphNode<#id>>.new()
    HashedSet<#id> blocked <- HashedSet<#id>.new()
    traverse (nodes.defaultOrder() -> GraphNode<#id> node) {
      traverse (node.outgoing().defaultOrder() -> GraphNode<#id> child) {
        $Hidden[node]$
        \ blocked.add(child.getId())
      }
    }
    traverse (nodes.defaultOrder() -> GraphNode<#id> node) {
      if (!blocked.member(node.getId())) {
        \ unblocked.append(node)
      }
    }
  }
}
