define GraphTree {
  @value Vector<#id> output
  @value HashedSet<#id> candidates
  @value HashedMap<#id,Int> refCounts
  @value KVReader<#id,DefaultOrder<#id>> blockers

  randomize (ready,blockers,random) {
    #self working <- #self{
        Vector<#id>.new(),
        HashedSet<#id>.new(),
        HashedMap<#id,Int>.new(),
        blockers }
    traverse (ready.defaultOrder() -> #id node) {
      \ working.unblockNode(node)
    }
    return working.execute(random).getOutput()
  }

  @value execute (Generator<Float>) -> (#self)
  execute (random) {
    while (candidates.size() > 0) {
      ReadAt<#id> ids, ReadAt<Float> weights <- cumulativeWeights()
      Int index <- weights `chooseRandom` random
      \ nextNodeIs(ids.readAt(index))
    }
    return self
  }

  @value nextNodeIs (#id) -> ()
  nextNodeIs (node) {
    \ output.append(node)
    \ candidates.remove(node)
    traverse (getBlockers(node) -> #id child) {
      $Hidden[node]$
      Int newCount <- require(refCounts.get(child))-1
      if (newCount == 0) {
        \ `refCounts.remove` child
        \ unblockNode(child)
      } else {
        \ child `refCounts.set` newCount
      }
    }
  }

  @type chooseRandom (ReadAt<Float>,Generator<Float>) -> (Int)
  chooseRandom (weights,random) {
    Float value <- weights.readAt(weights.size()-1)*random.generate()
    // NOTE: No point doing a binary search here since constructing `weights` is
    // already linear time. This is less error-prone.
    traverse (Counter.zeroIndexed(weights.size()) -> Int index) {
      if (value < weights.readAt(index)) {
        return index
      }
    }
    // Default to last in case of precision errors.
    return weights.size()-1
  }

  @value unblockNode (#id) -> ()
  unblockNode (node) {
    traverse (getBlockers(node) -> #id child) {
      $Hidden[node]$
      \ incrementRefCount(child)
    }
  }

  @value incrementRefCount (#id) -> ()
  incrementRefCount (node) {
    Int count <- 1
    scoped {
      optional Int existing <- refCounts.get(node)
    } in if (`present` existing) {
      count <- count+require(existing)
    }
    \ node `refCounts.set` count
  }

  @value cumulativeWeights () -> (ReadAt<#id>,ReadAt<Float>)
  cumulativeWeights () {
    Float cumulative <- 0.0
    Vector<#id> ids       <- Vector<#id>.new()
    Vector<Float> weights <- Vector<Float>.new()
    traverse (candidates.defaultOrder() -> #id node) {
      cumulative <- cumulative+1.0  // One point for the node itself.
      traverse (getBlockers(node) -> #id child) {
        $Hidden[node]$
        // Weights for children divided evenly among candidates.
        cumulative <- cumulative+1.0/require(refCounts.get(child)).asFloat()
      }
      \ ids.append(node)
      \ weights.append(cumulative)
    }
    return ids, weights
  }

  @value getBlockers (#id) -> (optional Order<#id>)
  getBlockers (node) {
    return require(blockers.get(node)).defaultOrder()
  }

  @value getOutput () -> (DefaultOrder<#id>)
  getOutput () { return output }
}
