define GraphTree {
  $ReadOnlyExcept[]$

  @value DefaultOrder<#id> unblocked
  @value KVReader<#id,DefaultOrder<#id>> blockers

  new (unblocked,blockers) {
    return #self{ unblocked, blockers }
  }

  newTraverser (selector) {
    return GraphTreeTraverser<#id>.new(unblocked,blockers,selector)
  }
}

concrete GraphTreeTraverser<#id> {
  refines GraphTraverser<#id>

  #id immutable
  #id requires Hashed
  #id defines Equals<#id>

  @type new (DefaultOrder<#id>,KVReader<#id,DefaultOrder<#id>>,IndexSelector) -> (#self)
}

define GraphTreeTraverser {
  $ReadOnlyExcept[]$

  refines GraphTraverser<#id>

  @value HashedSet<#id> candidates
  @value HashedMap<#id,Int> refCounts
  @value KVReader<#id,DefaultOrder<#id>> blockers
  @value IndexSelector selector

  new (unblocked,blockers,selector) {
    return #self{
        HashedSet<#id>.new(),
        HashedMap<#id,Int>.new(),
        blockers,
        selector
    }.setUnblocked(unblocked)
  }

  nextNode () (node) {
    node <- empty
    if (candidates.size() > 0) {
      if (candidates.size() == 1) {
        // Just use first node if that's the only one.
        node <- nextNodeIs(require(candidates.defaultOrder()).get())
      } else {
        ReadAt<#id> ids, ReadAt<Float> weights <- computeWeights()
        Int index <- `selector.selectFrom` weights
        node <- nextNodeIs(ids.readAt(index))
      }
    }
  }

  @value setUnblocked (DefaultOrder<#id>) -> (#self)
  setUnblocked (unblocked) {
    traverse (unblocked.defaultOrder() -> #id node) {
      \ unblockNode(node)
    }
    return self
  }

  @value nextNodeIs (#id) -> (#id)
  nextNodeIs (node) {
    \ candidates.remove(node)
    HashedSet<#id> stillBlocked <- HashedSet<#id>.new()
    traverse (getBlockers(node) -> #id child) {
      $Hidden[node]$
      Int newCount <- require(refCounts.get(child))-1
      \ child `refCounts.set` newCount
      if (newCount == 0) {
        traverse (getBlockers(child) -> #id childChild) {
          $Hidden[child]$
          \ stillBlocked.add(childChild)
        }
      } else {
        \ stillBlocked.add(child)
      }
    }
    // This covers the case where one child of `node` blocks another.
    traverse (getBlockers(node) -> #id child) {
      $Hidden[node]$
      if (!stillBlocked.member(child)) {
        \ refCounts.remove(child)
        \ unblockNode(child)
      }
    }
    return node
  }

  @value unblockNode (#id) -> ()
  unblockNode (node) {
    \ candidates.add(node)
    traverse (getBlockers(node) -> #id child) {
      $Hidden[node]$
      \ incrementRefCount(child)
    }
  }

  @value incrementRefCount (#id) -> ()
  incrementRefCount (node) {
    Int count <- 1
    scoped {
      optional Int existing <- refCounts.get(node)
    } in if (`present` existing) {
      count <- count+require(existing)
    }
    \ node `refCounts.set` count
  }

  @value computeWeights () -> (ReadAt<#id>,ReadAt<Float>)
  computeWeights () {
    Vector<#id> ids       <- Vector<#id>.new()
    Vector<Float> weights <- Vector<Float>.new()
    traverse (candidates.defaultOrder() -> #id node) {
      Float weight <- 1.0  // One point for the node itself.
      traverse (getBlockers(node) -> #id child) {
        $Hidden[node]$
        // Weights for children divided evenly among candidates.
        weight <- weight+1.0/require(refCounts.get(child)).asFloat()
      }
      \ ids.append(node)
      \ weights.append(weight)
    }
    return ids, weights
  }

  @value getBlockers (#id) -> (optional Order<#id>)
  getBlockers (node) {
    return require(blockers.get(node)).defaultOrder()
  }
}

define SelectRandom {
  @value Generator<Float> random

  with (random) {
    return #self{ random }
  }

  selectFrom (candidates) {
    Float total <- 0.0
    traverse (Counter.zeroIndexed(candidates.size()) -> Int index) {
      total <- total+candidates.readAt(index)
    }
    Float value <- random.generate()*total
    $Hidden[total]$
    traverse (Counter.zeroIndexed(candidates.size()) -> Int index) {
      if (value < candidates.readAt(index)) {
        return index
      } else {
        value <- value-candidates.readAt(index)
      }
    }
    // In case rounding errors push `value` past the end.
    return candidates.size()-1
  }
}

define BlockWithAll {
  new () {
    return #self{ }
  }

  getChildren (node,blockers) {
    HashedSet<#id> children <- HashedSet<#id>.new()
    traverse (node.outgoing().defaultOrder() -> GraphNode<#id> child) {
      $Hidden[node]$
      \ children.add(child.getId())
      scoped {
        optional DefaultOrder<#id> childBlockers <- blockers.get(child.getId())
      } in if (`present` childBlockers) {
        \ require(childBlockers).defaultOrder() `OrderH:copyTo` children
      }
    }
    return children
  }
}

define ComputeBlockers {
  with (nodes,policy) (unblocked,blockers) {
    unblocked <- Vector<#id>.new()
    blockers <- HashedMap<#id,DefaultOrder<#id>>.new()
    traverse (findUnblocked(nodes).defaultOrder() -> GraphNode<#id> node) {
      \ unblocked.append(node.getId())
      \ setBlockers(node,policy,blockers)
    }
  }

  @category setBlockers<#id>
    #id immutable
    #id requires Hashed
    #id defines Equals<#id>
  (GraphNode<#id>,BlockerPolicy<#id,GraphNode<#id>>,HashedMap<#id,DefaultOrder<#id>>) -> ()
  setBlockers (node,policy,blockers) {
    if (`present` blockers.get(node.getId())) {
      return _
    }
    // This mitigates potential cycles in the graph.
    \ node.getId() `blockers.set` AlwaysEmpty.default()
    traverse (node.outgoing().defaultOrder() -> GraphNode<#id> child) {
      $Hidden[node]$
      \ setBlockers(child,policy,blockers)
    }
    \ node.getId() `blockers.set` policy.getChildren(node,blockers)
  }


  @category findUnblocked<#id>
    #id immutable
    #id requires Hashed
    #id defines Equals<#id>
  (DefaultOrder<GraphNode<#id>>) -> (Vector<GraphNode<#id>>)
  findUnblocked (nodes) (unblocked) {
    unblocked <- Vector<GraphNode<#id>>.new()
    HashedSet<#id> blocked <- HashedSet<#id>.new()
    traverse (nodes.defaultOrder() -> GraphNode<#id> node) {
      traverse (node.outgoing().defaultOrder() -> GraphNode<#id> child) {
        $Hidden[node]$
        \ blocked.add(child.getId())
      }
    }
    traverse (nodes.defaultOrder() -> GraphNode<#id> node) {
      if (!blocked.member(node.getId())) {
        \ unblocked.append(node)
      }
    }
  }
}

define DualGraph {
  $ReadOnlyExcept[]$

  refines GraphNode<#id>

  @value #id id
  @value Vector<DualGraph<#id>> outgoing

  getId () {
    return id
  }

  outgoing () {
    return outgoing
  }

  from (nodes) {
    HashedMap<#id,DualGraph<#id>> parents <- HashedMap<#id,DualGraph<#id>>.new()
    traverse (nodes.defaultOrder() -> GraphNode<#id> node) {
      \ node `DualGraph<#id>.populateParents` parents
    }
    return parents.valueOrder() `OrderH:copyTo` Vector<DualGraph<#id>>.new()
  }

  @type populateParents (GraphNode<#id>,HashedMap<#id,DualGraph<#id>>) -> ()
  populateParents (node,parents) {
    if (`present` parents.get(node.getId())) {
      return _
    }
    DualGraph<#id> dualNode <- #self{ node.getId(), Vector<DualGraph<#id>>.new() }
    \ node.getId() `parents.set` dualNode
    traverse (node.outgoing().defaultOrder() -> GraphNode<#id> child) {
      \ populateParents(child,parents)
      \ require(parents.get(child.getId())).addParent(dualNode)
    }
  }

  @value addParent (DualGraph<#id>) -> ()
  addParent (parent) {
    \ outgoing.append(parent)
  }
}
