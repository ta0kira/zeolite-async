concrete WeightedGraphNode<#id> {
  refines WeightedNode<#id>

  #id immutable
  #id defines Equals<#id>

  @type new<#set>
    #set requires Append<#id>
    #set requires Container
    #set requires DefaultOrder<#id>
    #set defines Default
  (#id,Vector<WeightedGraphNode<#id>>) -> (#self)
  @value addParent (DualGraphNode<#id>) -> (#self)
  @value isBlocked () -> (Bool)
  @value invalidateSizes () -> ()
  @value invalidateWeights () -> ()
  @value getSize () -> (Float)
  @value getFractionalSize () -> (Float)
}

define WeightedGraphNode {
  $ReadOnlyExcept[size,totalParentsSize,totalWeight,totalChildWeights]$

  @value #id                                              id
  @value Vector<DualGraphNode<#id>>                       parents
  @value [DefaultOrder<WeightedGraphNode<#id>>&Container] children
  @value optional Float                                   totalWeight
  @value optional Float                                   size
  @value optional Float                                   totalParentsSize
  @value optional Float                                   totalChildWeights
  @value [DefaultOrder<#id>&Append<#id>&Container]        uniqueChildren

  new (id,children) {
    return #self{ id, Vector<DualGraphNode<#id>>.new(), children, empty, empty, empty, empty, #set.default() }
  }

  addParent (parent) {
    \ `parents.append` parent
    return self
  }

  isBlocked () {
    return parents.size() > 0
  }

  invalidateSizes () {
    $Hidden[totalWeight]$
    // Skip recursion if it's already happened.
    if (`present` size || `present` totalParentsSize) {
      size             <- empty
      totalParentsSize <- empty
      traverse (children.defaultOrder() -> WeightedGraphNode<#id> child) {
        \ child.invalidateSizes()
      }
      // Change in size means the weight is now invalid.
      \ invalidateWeights()
    }
  }

  invalidateWeights () {
    $Hidden[size]$
    // Skip recursion if it's already happened.
    if (`present` totalWeight) {
      totalWeight <- empty
      traverse (parents.defaultOrder() -> DualGraphNode<#id> parent) {
        \ parent.invalidateWeights()
      }
      // NOTE: Don't call `invalidateSizes()` here; it's not symmetric.
    }
  }

  getId () {
    return id
  }

  disownChildren (unblocked) {
    traverse (children.defaultOrder() -> WeightedGraphNode<#id> child) {
      \ child.removeParent(getId())
      if (!child.isBlocked()) {
        \ unblocked.append(child)
      }
    }
    return self
  }

  getWeight () {
    // Recursive down.
    $Hidden[size,parents,totalChildWeights]$
    if (! `present` totalWeight) {
      Float newWeight <- 1.0
      traverse (children.defaultOrder() -> WeightedGraphNode<#id> child) {
        newWeight <- newWeight+getSize()*child.getFractionalWeight()
      }
      totalWeight <- newWeight
    }
    return `require` totalWeight
  }

  getSize () {
    // Recursive up.
    $Hidden[totalWeight,children,totalChildWeights]$
    if (! `present` size) {
      Float newSize <- 1.0
      traverse (parents.defaultOrder() -> DualGraphNode<#id> parent) {
        newSize <- newSize+getSizeWeight()*parent.getFractionalSize()
      }
      size <- newSize
    }
    return `require` size
  }

  getFractionalSize () {
    return getSize()/getTotalChildWeights()
  }

  @value getTotalParentsSize () -> (Float)
  getTotalParentsSize () {
    if (! `present` totalParentsSize) {
      Float newSize <- 0.0
      traverse (parents.defaultOrder() -> DualGraphNode<#id> parent) {
        newSize <- newSize+parent.getSize()
      }
      totalParentsSize <- newSize
    }
    return `require` totalParentsSize
  }

  @value getUniqueChildren () -> ([DefaultOrder<#id>&Container])
  getUniqueChildren () {
    if (uniqueChildren.size() == 0) {
      \ `uniqueChildren.append` getId()
      traverse (children.defaultOrder() -> WeightedGraphNode<#id> child) {
        \ child.getUniqueChildren().defaultOrder() `OrderH:copyTo` uniqueChildren
      }
    }
    return uniqueChildren
  }

  @value getSizeWeight () -> (Float)
  getSizeWeight () {
    return getUniqueChildren().size().asFloat()
  }

  @value getTotalChildWeights () -> (Float)
  getTotalChildWeights () {
    $Hidden[size,parents,totalWeight]$
    if (! `present` totalChildWeights) {
      Float newWeight <- 0.0
      traverse (children.defaultOrder() -> WeightedGraphNode<#id> child) {
        newWeight <- newWeight+child.getSizeWeight()
      }
      totalChildWeights <- newWeight
    }
    return `require` totalChildWeights
  }

  @value getFractionalWeight () -> (Float)
  getFractionalWeight () {
    return getWeight()/getTotalParentsSize()
  }

  @value removeParent (#id) -> (#self)
  removeParent (parentId) {
    scoped {
      Bool shiftDown <- false
    } cleanup {
      if (shiftDown) {
        \ parents.pop()
        \ invalidateSizes()
      }
    } in traverse (Counter.zeroIndexed(parents.size()) -> Int index) {
      scoped {
        DualGraphNode<#id> parent <- parents.readAt(index)
      } in if (parent.getId() `#id.equals` parentId) {
        shiftDown <- true
      } else {
        if (shiftDown) {
          \ (index-1) `parents.writeAt` parent
        }
      }
    }
    return self
  }
}

concrete DualGraphNode<#id> {
  @type new (WeightedGraphNode<#id>) -> (DualGraphNode<#id>)
  @value getId () -> (#id)
  @value invalidateWeights () -> ()
  @value getSize () -> (Float)
  @value getFractionalSize () -> (Float)
}

define DualGraphNode {
  $ReadOnlyExcept[]$

  @value #id id
  @value weak WeightedGraphNode<#id> node

  new (node) {
    return #self{ node.getId(), node }
  }

  getId () {
    return id
  }

  invalidateWeights () {
    scoped {
      optional WeightedGraphNode<#id> node2 <- `strong` node
    } in if (`present` node2) {
      \ require(node2).invalidateWeights()
    }
  }

  getSize () {
    scoped {
      optional WeightedGraphNode<#id> node2 <- `strong` node
    } in if (`present` node2) {
      return require(node2).getSize()
    } else {
      return 0.0
    }
  }

  getFractionalSize () {
    scoped {
      optional WeightedGraphNode<#id> node2 <- `strong` node
    } in if (`present` node2) {
      return require(node2).getFractionalSize()
    } else {
      return 0.0
    }
  }
}

define WeightedGraphBuilder {
  @value [KVReader<#id,WeightedGraphNode<#id>>&KVWriter<#id,WeightedGraphNode<#id>>&ValueOrder<WeightedGraphNode<#id>>] nodes

  fromHashed (sources) {
    return WeightedGraphBuilder<#id>{ HashedMap<#id,WeightedGraphNode<#id>>.new() }.processAll<HashedSet<#id>>(sources).getNodes()
  }

  fromOrdered (sources) {
    return WeightedGraphBuilder<#id>{ SortedMap<#id,WeightedGraphNode<#id>>.new() }.processAll<SortedSet<#id>>(sources).getNodes()
  }

  @value processAll<#set>
    #set requires Append<#id>
    #set requires Container
    #set requires DefaultOrder<#id>
    #set defines Default
  (DefaultOrder<GraphNode<#id>>) -> (#self)
  processAll (sources) {
    traverse (sources.defaultOrder() -> GraphNode<#id> source) {
      \ process<#set>(source)
    }
    return self
  }

  @value process<#set>
    #set requires Append<#id>
    #set requires Container
    #set requires DefaultOrder<#id>
    #set defines Default
  (GraphNode<#id>) -> (WeightedGraphNode<#id>)
  process (source) (node) {
    scoped {
      optional WeightedGraphNode<#id> existing <- nodes.get(source.getId())
    } in if (`present` existing) {
      node <- `require` existing
    } else {
      Vector<WeightedGraphNode<#id>> children <- Vector<WeightedGraphNode<#id>>.new()
      traverse (source.outgoing().defaultOrder() -> GraphNode<#id> child) {
        \ children.append(process<#set>(child))
      }
      node <- WeightedGraphNode<#id>.new<#set>(source.getId(),children)
      \ node.getId() `nodes.set` node
      DualGraphNode<#id> dual <- DualGraphNode<#id>.new(node)
      traverse (children.defaultOrder() -> WeightedGraphNode<#id> child) {
        \ child.addParent(dual)
      }
    }
  }

  @value getNodes () -> (DefaultOrder<WeightedGraphNode<#id>>)
  getNodes () {
    Vector<WeightedGraphNode<#id>> unblocked <- Vector<WeightedGraphNode<#id>>.new()
    traverse (nodes.valueOrder() -> WeightedGraphNode<#id> node) {
      if (!node.isBlocked()) {
        \ unblocked.append(node)
      }
    }
    return unblocked
  }
}

define WeightedTraverser {
  $ReadOnlyExcept[]$

  refines Append<WeightedNode<#id>>
  refines GraphTraverser<#id>

  @value Bool traverseAll
  @value Vector<WeightedNode<#id>> candidates
  @value IndexSelector selector

  allWith (source,selector) {
    WeightedTraverser<#id> traverser <- WeightedTraverser<#id>{ true, Vector<WeightedNode<#id>>.new(), selector }
    traverse (source.defaultOrder() -> WeightedNode<#id> node) {
      \ traverser.append(node)
    }
    return traverser
  }

  pathWith (source,selector) {
    WeightedTraverser<#id> traverser <- WeightedTraverser<#id>{ false, Vector<WeightedNode<#id>>.new(), selector }
    traverse (source.defaultOrder() -> WeightedNode<#id> node) {
      \ traverser.append(node)
    }
    return traverser
  }

  nextNode () {
    if (candidates.size() == 0) {
      return empty
    }
    #id next <- defer
    if (candidates.size() == 1) {
      next <- candidates.readAt(0).getId()
    } else {
      next <- chooseRandom()
    }
    if (traverseAll) {
      \ consumeNodeForAll(next)
    } else {
      \ consumeNodeForPath(next)
    }
    return next
  }

  append (node) {
    \ `candidates.append` node
    return self
  }

  @value chooseRandom () -> (#id)
  chooseRandom () {
    Vector<Float> weights <- Vector<Float>.new()
    traverse (candidates.defaultOrder() -> WeightedNode<#id> node) {
      \ weights.append(node.getWeight())
    }
    return candidates.readAt(`selector.selectFrom` weights).getId()
  }

  @value consumeNodeForAll (#id) -> ()
  consumeNodeForAll (id) {
    optional WeightedNode<#id> consumed <- empty
    scoped {
      Bool shiftDown <- false
    } cleanup {
      if (shiftDown) {
        \ candidates.pop()
      }
    } in traverse (Counter.zeroIndexed(candidates.size()) -> Int index) {
      scoped {
        WeightedNode<#id> node <- candidates.readAt(index)
      } in if (node.getId() `#id.equals` id) {
        consumed <- node
        shiftDown <- true
      } elif (shiftDown) {
        \ (index-1) `candidates.writeAt` node
      }
    }
    if (`present` consumed) {
      \ require(consumed).disownChildren(self)
    }
  }

  @value consumeNodeForPath (#id) -> ()
  consumeNodeForPath (id) {
    optional WeightedNode<#id> consumed <- empty
    traverse (Counter.revZeroIndexed(candidates.size()) -> Int index) {
      scoped {
        WeightedNode<#id> node <- candidates.readAt(index)
      } in if (node.getId() `#id.equals` id) {
        consumed <- node
      } else {
        \ node.disownChildren(DiscardOutput.default())
      }
    } update {
      \ candidates.pop()
    }
    if (`present` consumed) {
      \ require(consumed).disownChildren(self)
    }
  }
}

define TreeTraverser {
  $ReadOnlyExcept[]$

  refines Append<SizedNode<#id>>
  refines GraphTraverser<#id>

  @value Bool traverseAll
  @value [KVExchange<#id,SizedNode<#id>>&KVWriter<#id,SizedNode<#id>>] candidates
  @value CategoricalTree<#id> weights
  @value RandomCategorical<#id> randomizer

  allWith (root,random) {
    CategoricalTree<#id> weights <- CategoricalTree<#id>.new()
    return TreeTraverser<#id>{
        true,
        SortedMap<#id,SizedNode<#id>>.new(),
        weights,
        weights `RandomCategorical:sampleWith` random
    }.append(root)
  }

  pathWith (root,random) {
    CategoricalTree<#id> weights <- CategoricalTree<#id>.new()
    return TreeTraverser<#id>{
        false,
        SortedMap<#id,SizedNode<#id>>.new(),
        weights,
        weights `RandomCategorical:sampleWith` random
    }.append(root)
  }

  append (node) {
    \ node.getId() `candidates.set` node
    \ node.getId() `weights.setWeight` node.getSize()
    return self
  }

  nextNode () {
    if (randomizer.isEmpty()) {
      return empty
    }
    #id next <- randomizer.generate()
    if (traverseAll) {
      \ consumeNodeForAll(next)
    } else {
      \ consumeNodeForPath(next)
    }
    return next
  }

  @value consumeNodeForAll (#id) -> ()
  consumeNodeForAll (id) {
    \ id `weights.setWeight` 0
    \ require(id `candidates.swap` empty).disownChildren(self)
  }

  @value consumeNodeForPath (#id) -> ()
  consumeNodeForPath (id) {
    optional SizedNode<#id> consumed <- empty
    while (weights.getTotal() > 0) {
      scoped {
        SizedNode<#id> node <- require(weights.locate(0) `candidates.swap` empty)
        \ node.getId() `weights.setWeight` 0
      } in if (node.getId() `#id.equals` id) {
        consumed <- node
      } else {
        \ node.disownChildren(DiscardOutput.default())
      }
    }
    if (`present` consumed) {
      \ require(consumed).disownChildren(self)
    }
  }
}

concrete DiscardOutput {
  refines Append<any>
  defines Default
}

define DiscardOutput {
  $ReadOnlyExcept[]$

  @category DiscardOutput singleton <- DiscardOutput{ }

  default () { return singleton }
  append (_) { return self }
}
