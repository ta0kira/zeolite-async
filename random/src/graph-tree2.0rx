concrete WeightedGraphNode<#id> {
  refines WeightedNode<#id>

  #id immutable
  #id defines Equals<#id>

  @type new (#id,DefaultOrder<WeightedGraphNode<#id>>) -> (#self)
  @value addParent (DualGraphNode<#id>) -> (#self)
  @value isBlocked () -> (Bool)
  @value invalidate () -> ()
}

define WeightedGraphNode {
  $ReadOnlyExcept[totalWeight,weightIsValid]$

  @value #id                                  id
  @value Vector<DualGraphNode<#id>>           parents
  @value DefaultOrder<WeightedGraphNode<#id>> children
  @value Float                                totalWeight
  @value Bool                                 weightIsValid

  new (id,children) {
    return #self{ id, Vector<DualGraphNode<#id>>.new(), children, 0.0, false }
  }

  addParent (parent) {
    \ `parents.append` parent
    return self
  }

  isBlocked () {
    return parents.size() > 0
  }

  invalidate () {
    // Skip recursion if it's already happened.
    if (weightIsValid) {
      weightIsValid <- false
      traverse (parents.defaultOrder() -> DualGraphNode<#id> parent) {
        \ parent.invalidate()
      }
    }
  }

  getId () {
    return id
  }

  getWeight () {
    if (!weightIsValid) {
      totalWeight <- 1.0
      traverse (children.defaultOrder() -> WeightedGraphNode<#id> child) {
        totalWeight <- totalWeight+child.getPartialWeight()
      }
      weightIsValid <- true
    }
    return totalWeight
  }

  disownChildren (unblocked) {
    traverse (children.defaultOrder() -> WeightedGraphNode<#id> child) {
      \ child.removeParent(getId())
      if (!child.isBlocked()) {
        \ unblocked.append(child)
      }
    }
    return self
  }

  @value getPartialWeight () -> (Float)
  getPartialWeight () {
    return getWeight()/parents.size().asFloat()
  }

  @value removeParent (#id) -> (#self)
  removeParent (parentId) {
    scoped {
      Bool shiftDown <- false
    } cleanup {
      if (shiftDown) {
        \ parents.pop()
      }
    } in traverse (Counter.zeroIndexed(parents.size()) -> Int index) {
      scoped {
        DualGraphNode<#id> parent <- parents.readAt(index)
      } in if (parent.getId() `#id.equals` parentId) {
        shiftDown <- true
      } else {
        \ parent.invalidate()
        if (shiftDown) {
          \ (index-1) `parents.writeAt` parent
        }
      }
    }
    return self
  }
}

concrete DualGraphNode<#id> {
  @type new (WeightedGraphNode<#id>) -> (DualGraphNode<#id>)
  @value getId () -> (#id)
  @value invalidate () -> ()
}

define DualGraphNode {
  $ReadOnlyExcept[]$

  @value #id id
  @value weak WeightedGraphNode<#id> node

  new (node) {
    return #self{ node.getId(), node }
  }

  getId () {
    return id
  }

  invalidate () {
    scoped {
      optional WeightedGraphNode<#id> node2 <- `strong` node
    } in if (`present` node2) {
      \ require(node2).invalidate()
    }
  }
}

define WeightedGraphBuilder {
  @value [KVReader<#id,WeightedGraphNode<#id>>&KVWriter<#id,WeightedGraphNode<#id>>&ValueOrder<WeightedGraphNode<#id>>] nodes

  fromHashed (sources) {
    return WeightedGraphBuilder<#id>{ HashedMap<#id,WeightedGraphNode<#id>>.new() }.processAll(sources).getNodes()
  }

  fromOrdered (sources) {
    return WeightedGraphBuilder<#id>{ SortedMap<#id,WeightedGraphNode<#id>>.new() }.processAll(sources).getNodes()
  }

  @value processAll (DefaultOrder<GraphNode<#id>>) -> (#self)
  processAll (sources) {
    traverse (sources.defaultOrder() -> GraphNode<#id> source) {
      \ process(source)
    }
    return self
  }

  @value process (GraphNode<#id>) -> (WeightedGraphNode<#id>)
  process (source) (node) {
    scoped {
      optional WeightedGraphNode<#id> existing <- nodes.get(source.getId())
    } in if (`present` existing) {
      node <- `require` existing
    } else {
      Vector<WeightedGraphNode<#id>> children <- Vector<WeightedGraphNode<#id>>.new()
      traverse (source.outgoing().defaultOrder() -> GraphNode<#id> child) {
        \ children.append(process(child))
      }
      node <- WeightedGraphNode<#id>.new(source.getId(),children)
      \ node.getId() `nodes.set` node
      DualGraphNode<#id> dual <- DualGraphNode<#id>.new(node)
      traverse (children.defaultOrder() -> WeightedGraphNode<#id> child) {
        \ child.addParent(dual)
      }
    }
  }

  @value getNodes () -> (DefaultOrder<WeightedGraphNode<#id>>)
  getNodes () {
    Vector<WeightedGraphNode<#id>> unblocked <- Vector<WeightedGraphNode<#id>>.new()
    traverse (nodes.valueOrder() -> WeightedGraphNode<#id> node) {
      if (!node.isBlocked()) {
        \ unblocked.append(node)
      }
    }
    return unblocked
  }
}

define WeightedTraverser {
  $ReadOnlyExcept[]$

  refines Append<WeightedNode<#id>>
  refines GraphTraverser<#id>

  @value Vector<WeightedNode<#id>> candidates
  @value IndexSelector selector

  with (source,selector) {
    WeightedTraverser<#id> traverser <- WeightedTraverser<#id>{ Vector<WeightedNode<#id>>.new(), selector }
    traverse (source.defaultOrder() -> WeightedNode<#id> node) {
      \ traverser.append(node)
    }
    return traverser
  }

  nextNode () {
    if (candidates.size() == 0) {
      return empty
    }
    #id next <- defer
    if (candidates.size() == 1) {
      next <- candidates.readAt(0).getId()
    } else {
      next <- chooseRandom()
    }
    \ consumeNode(next)
    return next
  }

  append (node) {
    \ `candidates.append` node
    return self
  }

  @value chooseRandom () -> (#id)
  chooseRandom () {
    Vector<Float> weights <- Vector<Float>.new()
    traverse (candidates.defaultOrder() -> WeightedNode<#id> node) {
      \ weights.append(node.getWeight())
    }
    return candidates.readAt(`selector.selectFrom` weights).getId()
  }

  @value consumeNode (#id) -> ()
  consumeNode (id) {
    optional WeightedNode<#id> consumed <- empty
    scoped {
      Bool shiftDown <- false
    } cleanup {
      if (shiftDown) {
        \ candidates.pop()
      }
    } in traverse (Counter.zeroIndexed(candidates.size()) -> Int index) {
      scoped {
        WeightedNode<#id> node <- candidates.readAt(index)
      } in if (node.getId() `#id.equals` id) {
        consumed <- node
        shiftDown <- true
      } elif (shiftDown) {
        \ (index-1) `candidates.writeAt` node
      }
    }
    if (`present` consumed) {
      \ require(consumed).disownChildren(self)
    }
  }
}

define TreeTraverser {
  $ReadOnlyExcept[]$

  refines Append<SizedNode<#id>>
  refines GraphTraverser<#id>

  @value [KVExchange<#id,SizedNode<#id>>&KVWriter<#id,SizedNode<#id>>] candidates
  @value CategoricalTree<#id> weights
  @value RandomCategorical<#id> randomizer

  with (root,random) {
    CategoricalTree<#id> weights <- CategoricalTree<#id>.new()
    return TreeTraverser<#id>{
        SortedMap<#id,SizedNode<#id>>.new(),
        weights,
        weights `RandomCategorical:sampleWith` random
    }.append(root)
  }

  append (node) {
    \ node.getId() `candidates.set` node
    \ node.getId() `weights.setWeight` node.getSize()
    return self
  }

  nextNode () {
    if (randomizer.isEmpty()) {
      return empty
    }
    #id next <- randomizer.generate()
    \ consumeNode(next)
    return next
  }

  @value consumeNode (#id) -> ()
  consumeNode (id) {
    \ id `weights.setWeight` 0
    \ require(id `candidates.swap` empty).disownChildren(self)
  }
}
