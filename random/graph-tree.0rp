concrete GraphTree<#id> {
  #id immutable
  #id requires Hashed
  #id defines Equals<#id>

  // Notes:
  // - Map of blockers must contain all nodes as keys.
  // - Children in blockers should include immediate children, but can also
  //   include indirect children to make weighting more accurate.
  // - Hypothesized worst-case computational complexity is O(VE) or O(V^3), with
  //   best case being O(V^2).
  @type new
  (DefaultOrder<KeyValue<#id,DefaultOrder<#id>>> /*blockedBy*/,
   KVReader<#id,DefaultOrder<#id>> /*blockers*/) ->
  (#self)

  @value newTraverser (IndexSelector) -> (GraphTraverser<#id>)
}

@value interface GraphTraverser<#id> {
  nextNode () -> (optional #id)
}

@value interface IndexSelector {
  selectFrom (ReadAt<Float>) -> (Int)
}

@value interface BlockerPolicy<#id,#n> {
  getChildren (#n,KVReader<#id,DefaultOrder<#id>>) -> (DefaultOrder<#id>)
}

concrete SelectRandom {
  refines IndexSelector

  @type with (Generator<Float>) -> (#self)
}

concrete SelectMax {
  refines IndexSelector

  @type new () -> (#self)
}

concrete BlockWithAll<#id> {
  refines BlockerPolicy<#id,GraphNode<#id>>
  #id immutable
  #id requires Hashed
  #id defines Equals<#id>

  @type new () -> (#self)
}

concrete BlockWithDirect<#id> {
  refines BlockerPolicy<#id,GraphNode<#id>>
  #id immutable
  #id requires Hashed
  #id defines Equals<#id>

  @type new () -> (#self)
}

concrete ComputeBlockers {
  @type with<#id>
    #id immutable
    #id requires Hashed
    #id defines Equals<#id>
  (DefaultOrder<GraphNode<#id>>,BlockerPolicy<#id,GraphNode<#id>> /*nodes*/) ->
  (HashedMap<#id,HashedSet<#id>> /*blockedBy*/,HashedMap<#id,DefaultOrder<#id>> /*blockers*/)
}

concrete DualGraph<#id> {
  #id immutable
  #id requires Hashed
  #id defines Equals<#id>

  @category from<#id>
    #id immutable
    #id requires Hashed
    #id defines Equals<#id>
  (DefaultOrder<GraphNode<#id>>) -> (DefaultOrder<GraphNode<#id>>)
}
