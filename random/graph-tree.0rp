concrete GraphTree<#id> {
  #id immutable
  #id requires Hashed
  #id defines Equals<#id>

  // Notes:
  // - Map of blockers must contain all nodes as keys.
  // - Children in blockers should include immediate children, but can also
  //   include indirect children to make weighting more accurate.
  // - Hypothesized worst-case computational complexity is O(VE) or O(V^3), with
  //   best case being O(V^2).
  @type randomize (
      [KVReader<#id,DefaultOrder<#id>>&DefaultOrder<KeyValue<#id,DefaultOrder<#id>>>] /*blockers*/,
      IndexSelector /*selector*/)
  -> (DefaultOrder<#id>)
}

@value interface IndexSelector {
  selectFrom (ReadAt<Float>) -> (Int)
}

@value interface BlockerPolicy<#id,#n> {
  getChildren (#n,KVReader<#id,DefaultOrder<#id>>) -> (DefaultOrder<#id>)
}

concrete SelectRandom {
  refines IndexSelector

  @type new (Generator<Float>) -> (#self)
}

concrete BlockWithAll<#id> {
  refines BlockerPolicy<#id,GraphNode<#id>>
  #id immutable
  #id requires Hashed
  #id defines Equals<#id>

  @type new () -> (#self)
}

concrete ComputeBlockers {
  @type with<#id>
    #id immutable
    #id requires Hashed
    #id defines Equals<#id>
  (DefaultOrder<GraphNode<#id>>,BlockerPolicy<#id,GraphNode<#id>>) -> (HashedMap<#id,DefaultOrder<#id>>)
}
