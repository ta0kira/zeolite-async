concrete Queue<#x> {
  @type new () -> (#self)
  @value push (#x) -> (#self)
  @value pop () -> (#x)
  @value isEmpty () -> (Bool)
}

define Queue {
  @value optional ForwardNode<#x> head
  @value optional ForwardNode<#x> tail

  new () {
    return #self{ empty, empty }
  }

  push (x) {
    scoped {
      ForwardNode<#x> node <- ForwardNode<#x>.newNode(x)
    } in if (`present` tail) {
      \ require(tail).setNext(node)
      tail <- node
    } else {
      head <- (tail <- node)
    }
    return self
  }

  pop () {
    cleanup {
      head <- require(head).next()
      if (! `present` head) {
        tail <- empty
      }
    } in return require(head).get()
  }

  isEmpty () {
    return ! `present` head
  }
}

concrete GetIds<#id> {
  refines AsyncCollector<#id>
  #id immutable
  #id defines Equals<#id>
  #id requires Hashed

  @type new () -> (#self)
  @value allIds () -> (DefaultOrder<#id>)
}

define GetIds {
  @value HashedSet<#id> allIds

  new () {
    return #self{ HashedSet<#id>.new() }
  }

  include (node,_) {
    \ allIds.add(node.getId())
    return self
  }

  allIds () {
    return allIds
  }
}

define Compute {
  $ReadOnly[idToNode,depends,blocking,execQueue,waitQueue]$

  refines AsyncCollector<#id>
  refines ExecQueue<#id>

  // TODO: Add a Mutex.
  @value HashedMap<#id,AsyncRun<#id>> idToNode
  @value HashedMap<#id,HashedSet<#id>> depends
  @value HashedMap<#id,HashedSet<#id>> blocking
  @value Queue<AsyncRun<#id>> execQueue
  @value Queue<AsyncRun<#id>> waitQueue

  with (x,runner) {
    Compute<#id,#x> compute <- Compute<#id,#x>{
        HashedMap<#id,AsyncRun<#id>>.new(),
        HashedMap<#id,HashedSet<#id>>.new(),
        HashedMap<#id,HashedSet<#id>>.new(),
        Queue<AsyncRun<#id>>.new(),
        Queue<AsyncRun<#id>>.new() }
    \ x.collect(compute)
    \ compute.initQueue()
    \ runner.runAll(compute)
    return x.get()
  }

  include (node,blockers) {
    scoped {
      optional HashedSet<#id> existing <- `depends.get` node.getId()
    } in if (! `present` existing) {
      #id id <- node.getId()
      \ id `idToNode.set` node
      HashedSet<#id> newBlockers <- defer
      \ id `depends.set` (newBlockers <- HashedSet<#id>.new())
      // This is used by the parent call.
      \ id `blocking.set` HashedSet<#id>.new()
      traverse (blockers.defaultOrder() -> AsyncNode<#id> blocker) {
        \ blocker.collect(self)
        GetIds<#id> ids <- GetIds<#id>.new()
        \ blocker.collect(ids)
        traverse (ids.allIds().defaultOrder() -> #id id2) {
          \ newBlockers.add(id2)
          // NOTE: The recursive call must come before this so that there's a
          // blocking entry for id2.
          \ require(blocking.get(id2)).add(id)
        }
      }
    }
    return self
  }

  nextExec () {
    $Hidden[waitQueue]$
    if (execQueue.isEmpty()) {
      return empty
    } else {
      return execQueue.pop()
    }
  }

  nextWait () {
    $Hidden[execQueue]$
    if (waitQueue.isEmpty()) {
      return empty
    } else {
      return waitQueue.pop()
    }
  }

  finishTask (node) {
    return completeId(node.getId())
  }

  queueWait (node) {
    $Hidden[execQueue]$
    \ waitQueue.push(node)
  }

  @value completeId (#id) -> (Bool)
  completeId (id) (unblocked) {
    unblocked <- false
    scoped {
      HashedSet<#id> wasBlocking <- `require` (id `blocking.swap` empty)
    } in traverse (wasBlocking.defaultOrder() -> #id node) {
      scoped {
        HashedSet<#id> remaining <- require(depends.get(node)).remove(id)
      } in if (remaining.size() == 0) {
        unblocked <- true
        \ depends.remove(node)
        \ execQueue.push(`require` `idToNode.get` node)
      }
    }
  }

  @value initQueue () -> ()
  initQueue () {
    traverse (depends.defaultOrder() -> KeyValue<#id,Container> keyValue) {
      if (keyValue.getValue().size() == 0) {
        \ execQueue.push(`require` `idToNode.get` keyValue.getKey())
      }
    }
  }
}

define InlineRunner {
  new () {
    return #self{ }
  }

  runAll (queue) {
    scoped {
      Bool changed <- true
    } in while (changed) {
      changed <- runExec(queue)
      // Order matters here, due to short-circuiting.
      changed <- runWait(queue) || changed
    }
  }

  @value runExec (ExecQueue<#id>) -> (Bool)
  runExec (queue) (changed) {
    changed <- false
    scoped {
      optional AsyncRun<#id> node <- empty
    } in while (`present` (node <- queue.nextExec())) {
      changed <- true
      \ require(node).start()
      if (require(node).tryFinish()) {
        \ queue.finishTask(`require` node)
      } else {
        \ queue.queueWait(`require` node)
      }
    }
  }

  @value runWait (ExecQueue<#id>) -> (Bool)
  runWait (queue) (changed) {
    changed <- false
    // 1. Attempt to finish all nodes in the wait queue without blocking.
    // 2. If any of them result in another node being unblocked, return control.
    // 3. Otherwise, do a blocking wait and return as soon as any other nodes
    //    are unblocked.
    Bool unblocked <- false
    Queue<AsyncRun<#id>> waitQueue <- Queue<AsyncRun<#id>>.new()
    scoped {
      optional AsyncRun<#id> node <- empty
    } in while (`present` (node <- queue.nextWait())) {
      changed <- true
      if (!require(node).tryFinish()) {
        \ waitQueue.push(`require` node)
      } else {
        unblocked <- unblocked || queue.finishTask(`require` node)
      }
    }
    while (!waitQueue.isEmpty()) {
      \ queue.queueWait(waitQueue.pop())
    }
    $Hidden[waitQueue]$
    if (!unblocked) {
      scoped {
        optional AsyncRun<#id> node <- empty
      } in while (`present` (node <- queue.nextWait())) {
        \ require(node).finish()
        if (queue.finishTask(`require` node)) {
          break
        }
      }
    }
  }
}

define AsyncId {
  @category Mutex mutex <- SpinlockMutex.new()
  @category Int lastId <- 0
  @value Int id

  new () {
    scoped {
      MutexLock lock <- MutexLock.lock(mutex)
    } cleanup {
      \ lock.freeResource()
    } in {
      return AsyncId{ (lastId <- lastId+1) }
    }
  }

  equals (x,y) { return x.id() == y.id() }
  lessThan (x,y) { return x.id() < y.id() }
  formatted () { return String.builder().append("AsyncId{").append(id).append("}").build() }
  hashed () { return id.hashed() }

  @value id () -> (Int)
  id () { return id }
}

define AsyncSum {
  $ReadOnly[id,deps]$

  refines AsyncRun<AsyncId>

  @value AsyncId id
  @value optional Float result
  @value DefaultOrder<[AsyncValue<AsFloat>&AsyncNode<AsyncId>]> deps

  new (deps) {
    return #self{ AsyncId.new(), empty, deps.defaultOrder() `OrderH:copyTo` Vector<[AsyncValue<AsFloat>&AsyncNode<AsyncId>]>.new() }
  }

  get () { return `require` result }
  getId () { return id }
  collect (collector) { \ self `collector.include` deps }

  start () {
    if (! `present` result) {
      Float result2 <- 0.0
      traverse (deps.defaultOrder() -> AsyncValue<AsFloat> dep) {
        $Hidden[result]$
        result2 <- result2+dep.get().asFloat()
      }
      result <- result2
    }
    return self
  }

  finish () {
    return self
  }

  tryFinish () {
    return `present` result
  }
}

define AsyncFactorial {
  $ReadOnly[id,limit]$

  refines AsyncRun<AsyncId>

  @value AsyncId id
  @value optional Int result
  @value Int limit

  new (limit) {
    return #self{ AsyncId.new(), empty, limit }
  }

  get () { return `require` result }
  getId () { return id }
  collect (collector) { \ self `collector.include` AlwaysEmpty.default() }

  start () {
    if (! `present` result) {
      Int result2 <- 1
      traverse (`Counter.zeroIndexed` limit -> Int minus1) {
        $Hidden[result]$
        result2 <- result2*(minus1+1)
      }
      result <- result2
    }
    return self
  }

  finish () {
    return self
  }

  tryFinish () {
    return `present` result
  }
}
