concrete TopoTest {
  @type run () -> ()
}

define TopoTest {
  run () {
    Int count <- 1000
    if (Argv.global().size() > 1) {
      count <- ParseChars.int(Argv.global().readAt(1)).getValue()
    }

    Generator<Float> random <- RandomUniform.probability().setSeed(Realtime.monoSeconds().asInt())

    TestNode node1 <- TestNode.new(1,Vector<TestNode>.new())
    TestNode node2 <- TestNode.new(2,Vector<TestNode>.new())
    TestNode node3 <- TestNode.new(3,Vector<TestNode>.new()
        .append(node1)
        .append(node2))
    TestNode node4 <- TestNode.new(4,Vector<TestNode>.new()
        .append(node1)
        .append(node3))
    TestNode node5 <- TestNode.new(5,Vector<TestNode>.new()
        .append(node1))
    TestNode node6 <- TestNode.new(6,Vector<TestNode>.new())
    TestNode node7 <- TestNode.new(7,Vector<TestNode>.new()
        .append(node6))

    Vector<TestNode> allNodes <- Vector<TestNode>.new()
        .append(node1)
        .append(node2)
        .append(node3)
        .append(node4)
        .append(node5)
        .append(node6)
        .append(node7)
    $ReadOnly[node1,node2,node3,node4,node5,node6,node7]$

    TopoSort<TestNode,Int> topoSort <- `TopoSort:relationFrom<?,Int>` allNodes

    traverse (`Counter.zeroIndexed` count -> Int i) {
      Vector<TestNode> copy <- allNodes.duplicate()
      $Hidden[allNodes]$
      \ copy `topoSort.fastRandom` random
      \ formatNodes(copy,topoSort)
      \ BasicOutput.stderr()
          .write(i)
          .write("\n")
          .flush()
    }
  }

  @type formatNodes (ReadAt<TestNode>,TopoSort<TestNode,Int>) -> ()
  formatNodes (allNodes,topoSort) {
    traverse (`ReadAtH:forwardOrder` allNodes -> TestNode node) {
      \ BasicOutput.stdout()
          .write(node.getId())
          .write(" ")
          .flush()
    }
    \ BasicOutput.stdout()
        .write(`topoSort.isSorted` allNodes)
        .write("\n")
        .flush()
  }
}

concrete TestNode {
  refines GraphNode<Int>

  @type new (Int,ReadAt<TestNode>) -> (#self)
}

define TestNode {
  $ReadOnly[id,outgoing]$

  @value Int id
  @value ReadAt<TestNode> outgoing

  new (id,outgoing) {
    return #self{ id, outgoing }
  }

  getId () {
    return id
  }

  outgoing () {
    return outgoing
  }
}
