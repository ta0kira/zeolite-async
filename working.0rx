concrete TopoTest {
  @type run () -> ()
}

define TopoTest {
  run () {
    Int count <- 1000
    if (Argv.global().size() > 1) {
      count <- ParseChars.int(Argv.global().readAt(1)).getValue()
    }

    Generator<Float> random <- RandomUniform.probability().setSeed(Realtime.monoSeconds().asInt())

    TestNode node1 <- TestNode.new(1,Vector<TestNode>.new())
    TestNode node2 <- TestNode.new(2,Vector<TestNode>.new())
    TestNode node3 <- TestNode.new(3,Vector<TestNode>.new()
        .append(node1)
        .append(node2))
    TestNode node4 <- TestNode.new(4,Vector<TestNode>.new()
        .append(node1)
        .append(node3))
    TestNode node5 <- TestNode.new(5,Vector<TestNode>.new()
        .append(node1))
    TestNode node6 <- TestNode.new(6,Vector<TestNode>.new())
    TestNode node7 <- TestNode.new(7,Vector<TestNode>.new()
        .append(node6))

    ReadAt<TestNode> allNodes <- Vector<TestNode>.new()
        .append(node1)
        .append(node2)
        .append(node3)
        .append(node4)
        .append(node5)
        .append(node6)
        .append(node7)
    $ReadOnly[allNodes,node1,node2,node3,node4,node5,node6,node7]$

//     Vector<TestNode> allNodes <- Vector<TestNode>.new()
//     traverse (Counter.zeroIndexed(1000) -> Int id) {
//       \ allNodes.append(TestNode.new(id,allNodes.duplicate()))
//     }

    TopoSort<TestNode,Int> topoSort <- `TopoSort:relationFrom<?,Int>` allNodes
//     TopoSort<TestNode,Int> topoSort <- `TopoSort:relationFrom<?,Int>` allNodes
    $Hidden[allNodes]$

    ReadAt<Int> nodes <- Vector<Int>.new()
//           .append(999)
        .append(1)
        .append(2)
        .append(3)
        .append(4)
        .append(5)
        .append(6)
        .append(7)

    traverse (`Counter.zeroIndexed` count -> Int i) {
      Vector<TestNode> copy <- Vector<TestNode>.new()
      scoped {
        GraphQueue<TestNode> queue <- nodes `topoSort.graphQueue` random
        optional TestNode node <- empty
      } cleanup {
        \ queue.finish(node)
      } in while (`present` (node <- queue.exchange(node))) {
      \ BasicOutput.stderr()
          .write(".")
          .flush()
        \ copy.append(`require` node)
      }
      \ formatNodes(copy)
      \ BasicOutput.stderr()
          .write(i)
          .write("\n")
          .flush()
    }
  }

  @type formatNodes (ReadAt<TestNode>) -> ()
  formatNodes (nodes) {
    traverse (`ReadAtH:forwardOrder` nodes -> TestNode node) {
      \ BasicOutput.stdout()
          .write(node.getId())
          .write(" ")
          .flush()
    }
    \ BasicOutput.stdout()
        .write("\n")
        .flush()
  }
}

concrete TestNode {
  refines GraphNode<Int>

  @type new (Int,ReadAt<TestNode>) -> (#self)
}

define TestNode {
  $ReadOnly[id,outgoing]$

  @value Int id
  @value ReadAt<TestNode> outgoing

  new (id,outgoing) {
    return #self{ id, outgoing }
  }

  getId () {
    return id
  }

  outgoing () {
    return outgoing
  }
}
