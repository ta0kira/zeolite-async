concrete ChainExec<#id> {
  refines AsyncNode<#id>
  refines AsyncValue<ErrorOr<Int>>

  @category asyncRun<#id>
    #id defines UniqueId
  ([AsyncTask&AsyncValue<ErrorOr<Int>>]) -> (ChainExec<#id>)

  @value after ([AsyncNode<#id>&AsyncValue<ErrorOr<Int>>]) -> (#self)
}

concrete Command {
  refines AsyncTask
  refines AsyncValue<ErrorOr<Int>>

  // NOTE: If the descriptor is non-empty and not stdin, stdout, or stderr, then
  // it will be closed upon start().
  @type new (String,
             ReadAt<String>,
             optional FileDescriptor,
             optional FileDescriptor,
             optional FileDescriptor) ->
            (Command)

  @value runOnce () -> (ErrorOr<Int>)
  @value runDetached () -> (ErrorOr<Int>)
}

concrete CommandBuilder {
  refines Build<Command>
  refines Append<Formatted>

  @type for (String) -> (CommandBuilder)

  @value addArg (Formatted) -> (#self)

  // NOTE: If the descriptor is non-empty and not stdin, stdout, or stderr, then
  // it will be closed upon start().

  @value setStdin  (optional FileDescriptor) -> (#self)
  @value setStdout (optional FileDescriptor) -> (#self)
  @value setStderr (optional FileDescriptor) -> (#self)
}

concrete FileDescriptor {
  immutable

  @type new (Int) -> (FileDescriptor)
  @type stdin () -> (FileDescriptor)
  @type stdout () -> (FileDescriptor)
  @type stderr () -> (FileDescriptor)
  @value get () -> (Int)
}

concrete Files {
  @type pipe () -> (FileDescriptor,FileDescriptor)
  @type close (FileDescriptor) -> ()
  @type closeExec (FileDescriptor,Bool) -> (FileDescriptor)
  @type blocking (FileDescriptor,Bool) -> (FileDescriptor)
  @type validate (FileDescriptor) -> (ErrorOr<FileDescriptor>)
}

concrete CommandPipe {
  refines Build<[AsyncTask&AsyncValue<ErrorOr<Int>>]>

  @type begin (CommandBuilder) -> (#self)
  @value pipeStdout (CommandBuilder) -> (#self)
  @value pipeStderr (CommandBuilder) -> (#self)
}
