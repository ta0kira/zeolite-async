testcase "AsyncExec tests" {
  success
  timeout 5
}

unittest success {
  AsyncExec<AsyncId> command <- "/bin/true" `AsyncExec:withArgs<AsyncId>` AlwaysEmpty.default()
  scoped {
    CollectSingle<AsyncId> collector <- CollectSingle<AsyncId>.new()
    \ command.collect(collector)
  } in AsyncRun<AsyncId> node, _ <- collector.get()
  \ node.start().finish()
  \ UtilTesting.checkSuccess(command.get(),0)
}

unittest runOnce {
  AsyncExec<AsyncId> command <- "/bin/sleep" `AsyncExec:withArgs<AsyncId>` Vector<Int>.new().append(1)
  // Make sure the count here is > the testcase timeout.
  \ UtilTesting.checkSuccess(command.runOnce(),0)
  \ UtilTesting.checkSuccess(command.runOnce(),0)
  \ UtilTesting.checkSuccess(command.runOnce(),0)
  \ UtilTesting.checkSuccess(command.runOnce(),0)
  \ UtilTesting.checkSuccess(command.runOnce(),0)
  \ UtilTesting.checkSuccess(command.runOnce(),0)
  \ UtilTesting.checkSuccess(command.get(),0)
}

unittest blockingNodes {
  AsyncExec<AsyncId> command <- "/bin/true" `AsyncExec:withArgs<AsyncId>` AlwaysEmpty.default()
  scoped {
    CollectSingle<AsyncId> collector <- CollectSingle<AsyncId>.new()
    \ command.collect(collector)
  } in _, DefaultOrder<AsyncNode<AsyncId>> blocking <- collector.get()
  traverse (blocking.defaultOrder() -> _) {
    fail("expected empty")
  }
}

unittest tryFinish {
  AsyncExec<AsyncId> command <- "/bin/sleep" `AsyncExec:withArgs<AsyncId>` Vector<Float>.new().append(0.5)
  scoped {
    CollectSingle<AsyncId> collector <- CollectSingle<AsyncId>.new()
    \ command.collect(collector)
  } in AsyncRun<AsyncId> node, _ <- collector.get()
  \ node.start()
  Bool pending <- false
  while (!node.tryFinish()) {
    pending <- true
  }
  \ UtilTesting.checkSuccess(command.get(),0)
}

unittest idempotent {
  AsyncExec<AsyncId> command <- "/bin/true" `AsyncExec:withArgs<AsyncId>` AlwaysEmpty.default()
  scoped {
    CollectSingle<AsyncId> collector <- CollectSingle<AsyncId>.new()
    \ command.collect(collector)
  } in AsyncRun<AsyncId> node, _ <- collector.get()
  \ node.start().start().finish().finish()
  \ UtilTesting.checkSuccess(command.get(),0)
}

unittest failure {
  AsyncExec<AsyncId> command <- "/bin/false" `AsyncExec:withArgs<AsyncId>` AlwaysEmpty.default()
  scoped {
    CollectSingle<AsyncId> collector <- CollectSingle<AsyncId>.new()
    \ command.collect(collector)
  } in AsyncRun<AsyncId> node, _ <- collector.get()
  \ node.start().finish()
  \ UtilTesting.checkSuccessBetween(command.get(),0,256)
}

unittest badBinary {
  AsyncExec<AsyncId> command <- "/path/to/bad" `AsyncExec:withArgs<AsyncId>` AlwaysEmpty.default()
  scoped {
    CollectSingle<AsyncId> collector <- CollectSingle<AsyncId>.new()
    \ command.collect(collector)
  } in AsyncRun<AsyncId> node, _ <- collector.get()
  \ node.start().finish()
  \ UtilTesting.checkSuccessBetween(command.get(),0,256)
}


testcase "AsyncExec finish without start" {
  crash
  require "started"
}

unittest test {
  AsyncExec<AsyncId> command <- "/bin/true" `AsyncExec:withArgs<AsyncId>` AlwaysEmpty.default()
  scoped {
    CollectSingle<AsyncId> collector <- CollectSingle<AsyncId>.new()
    \ command.collect(collector)
  } in AsyncRun<AsyncId> node, _ <- collector.get()
  \ node.finish()
}


testcase "AsyncExec get without start" {
  crash
  require "started"
}

unittest test {
  AsyncExec<AsyncId> command <- "/bin/true" `AsyncExec:withArgs<AsyncId>` AlwaysEmpty.default()
  scoped {
    CollectSingle<AsyncId> collector <- CollectSingle<AsyncId>.new()
    \ command.collect(collector)
  } in AsyncRun<AsyncId> node, _ <- collector.get()
  \ command.get()
}


testcase "AsyncExec get without finish" {
  crash
  require "completed"
}

unittest test {
  AsyncExec<AsyncId> command <- "/bin/true" `AsyncExec:withArgs<AsyncId>` AlwaysEmpty.default()
  scoped {
    CollectSingle<AsyncId> collector <- CollectSingle<AsyncId>.new()
    \ command.collect(collector)
  } in AsyncRun<AsyncId> node, _ <- collector.get()
  \ node.start()
  \ command.get()
}
