define ChainExec {
  $ReadOnlyExcept[result,locked]$

  refines AsyncRun<#id>

  @value optional ErrorOr<Int> result
  @value #id id
  @value [AsyncTask&AsyncValue<ErrorOr<Int>>] command
  @value Vector<[AsyncNode<#id>&AsyncValue<ErrorOr<Int>>]> deps
  // TODO: This is kind of a hack => make it safe at compile time.
  @value Bool locked

  asyncRun (command) {
    return ChainExec<#id>{
        empty,
        #id.newId(),
        command,
        Vector<[AsyncNode<#id>&AsyncValue<ErrorOr<Int>>]>.new(),
        false }
  }

  after (dep) {
    if (locked) {
      fail("command already started")
    }
    \ deps.append(dep)
    return self
  }

  getId () {
    return id
  }

  start () {
    traverse (deps.defaultOrder() -> AsyncValue<ErrorOr<Int>> dep) {
      scoped {
        ErrorOr<Int> status <- dep.get()
      } in if (status.isError() || status.getValue() != 0) {
        // Don't run the command if a dependency had an error.
        result <- status
        return self
      }
    }
    \ command.start()
    return self
  }

  finish () {
    if (`present` result) {
      // Command was already skipped due to dependency error.
      return self
    }
    \ command.finish()
    return self
  }

  tryFinish () (complete) {
    if (`present` result) {
      // Command was already skipped due to dependency error.
      return true
    }
    return command.tryFinish()
  }

  collect (collector) {
    locked <- true
    \ self `collector.include` deps
  }

  get () {
    if (!`present` result) {
      traverse (deps.defaultOrder() -> AsyncValue<ErrorOr<Int>> dep) {
        scoped {
          ErrorOr<Int> status <- dep.get()
        } in if (status.isError() || status.getValue() != 0) {
          result <- status
          break
        }
      }
    }
    if (! `present` result) {
      result <- command.get()
    }
    return `require` result
  }
}

define CommandBuilder {
  $ReadOnly[command,args]$

  @value String command
  @value [ReadAt<String>&Append<String>] args
  @value optional FileDescriptor stdin
  @value optional FileDescriptor stdout
  @value optional FileDescriptor stderr

  for (command) {
    return CommandBuilder{ command, Vector<String>.new(), empty, empty, empty }
  }

  append (arg) {
    return addArg(arg)
  }

  addArg (arg) {
    \ args.append(arg.formatted())
    return self
  }

  setStdin (stdin2) {
    stdin <- stdin2
    return self
  }

  setStdout (stdout2) {
    stdout <- stdout2
    return self
  }

  setStderr (stderr2) {
    stderr <- stderr2
    return self
  }

  build () {
    return Command.new(command,args,stdin,stdout,stderr)
  }
}

define FileDescriptor {
  @value Int fd

  new (fd) {
    scoped {
      ErrorOr<FileDescriptor> descriptor <- Files.validate(FileDescriptor{ fd })
    } in if (descriptor.isError()) {
      fail(String.builder()
          .append("File descriptor ")
          .append(fd)
          .append(" is invalid: ")
          .append(descriptor.getError())
          .build())
    } else {
      return descriptor.getValue()
    }
  }

  stdin () { return new(0) }
  stdout () { return new(1) }
  stderr () { return new(2) }
  get () { return fd }
}

concrete AggregateCommand {
  refines AsyncTask
  refines AsyncValue<ErrorOr<Int>>

  @type new (DefaultOrder<[AsyncTask&AsyncValue<ErrorOr<Int>>]>) -> (#self)
}

define AggregateCommand {
  $ReadOnlyExcept[result]$

  @value optional ErrorOr<Int> result
  @value DefaultOrder<[AsyncTask&AsyncValue<ErrorOr<Int>>]> commands

  new (commands) {
    return #self{
        empty,
        commands.defaultOrder() `OrderH:copyTo` Vector<[AsyncTask&AsyncValue<ErrorOr<Int>>]>.new() }
  }

  start () {
    if (`present` result) {
      return self
    }
    traverse (commands.defaultOrder() -> AsyncTask command) {
      \ command.start()
    }
    return self
  }

  finish () {
    if (`present` result) {
      return self
    }
    traverse (commands.defaultOrder() -> AsyncTask command) {
      \ command.finish()
    }
    return self
  }

  tryFinish () (complete) {
    if (`present` result) {
      return true
    }
    complete <- true
    traverse (commands.defaultOrder() -> AsyncTask command) {
      complete <- command.tryFinish() && complete
    }
  }

  get () {
    if (! `present` result) {
      ErrorOr<Int> result2 <- ErrorOr:value(0)
      traverse (commands.defaultOrder() -> AsyncValue<ErrorOr<Int>> node) {
        ErrorOr<Int> value <- node.get()
        if (value.isError() || value.getValue() != 1) {
          result2 <- value
          break
        }
      }
      result <- result2
    }
    return `require` result
  }
}

define CommandPipe {
  @value Vector<CommandBuilder> builders
  @value CommandBuilder lastBuilder

  begin (builder) {
    return #self{
        Vector<CommandBuilder>.new().append(builder),
        builder }
  }

  pipeStdout (builder) {
    \ builders.append(builder)
    FileDescriptor read, FileDescriptor write <- Files.pipe()
    \ `lastBuilder.setStdout` write
    \ `builder.setStdin`      read
    lastBuilder <- builder
    return self
  }

  pipeStderr (builder) {
    \ builders.append(builder)
    FileDescriptor read, FileDescriptor write <- Files.pipe()
    \ `lastBuilder.setStderr` write
    \ `builder.setStdin`      read
    lastBuilder <- builder
    return self
  }

  build () {
    Vector<Command> commands <- Vector<Command>.new()
    traverse (builders.defaultOrder() -> CommandBuilder builder) {
      \ commands.append(builder.build())
    }
    return AggregateCommand.new(commands)
  }
}
