define AsyncExec {
  $ReadOnlyExcept[]$

  refines AsyncRun<#id>

  @value #id id
  @value Command command

  withArgs (command,args) {
    return AsyncExec<#id>{
        #id.newId(),
        (args `ReadAtH:copyTo` CommandBuilder.for(command)).build() }
  }

  runOnce () {
    return start().finish().get()
  }

  getId () {
    return id
  }

  collect (collector) {
    \ collector.include(self,AlwaysEmpty.default())
  }

  start () {
    \ command.start()
    return self
  }

  finish () {
    \ command.finish()
    return self
  }

  tryFinish () {
    return command.tryFinish()
  }

  get () {
    return command.get()
  }
}

define ChainExec {
  $ReadOnlyExcept[result]$

  refines AsyncRun<#id>
  refines AsyncCollector<#id>

  @value optional ErrorOr<Int> result
  @value #id id
  @value AsyncValue<ErrorOr<Int>>         exec
  @value Vector<AsyncRun<#id>>            run
  @value Vector<AsyncValue<ErrorOr<Int>>> deps
  @value Vector<AsyncNode<#id>>           blocking

  runAfter (exec,nodes) {
    Vector<AsyncValue<ErrorOr<Int>>> deps     <- Vector<AsyncValue<ErrorOr<Int>>>.new()
    Vector<AsyncNode<#id>>           blocking <- Vector<AsyncNode<#id>>.new()
    \ nodes.defaultOrder() `OrderH:copyTo<AsyncValue<ErrorOr<Int>>,?>` deps
    \ nodes.defaultOrder() `OrderH:copyTo<AsyncNode<#id>,?>`           blocking
    ChainExec<#id> chained <- ChainExec<#id>{
        empty,
        #id.newId(),
        exec,
        Vector<AsyncRun<#id>>.new(),
        deps,
        blocking }
    \ exec.collect(chained)
    return chained
  }

  include (node,blocking2) {
    \ run.append(node)
    \ blocking2.defaultOrder() `OrderH:copyTo` blocking
    return self
  }

  getId () {
    return id
  }

  start () {
    traverse (deps.defaultOrder() -> AsyncValue<ErrorOr<Int>> dep) {
      scoped {
        ErrorOr<Int> status <- dep.get()
      } in if (status.isError() || status.getValue() != 0) {
        // Don't run the command if a dependency had an error.
        result <- status
        return self
      }
    }
    traverse (run.defaultOrder() -> AsyncRun<#id> process) {
      \ process.start()
    }
    return self
  }

  finish () {
    if (`present` result) {
      // Command was already skipped due to dependency error.
      return self
    }
    traverse (run.defaultOrder() -> AsyncRun<#id> process) {
      \ process.finish()
    }
    return self
  }

  tryFinish () (complete) {
    if (`present` result) {
      // Command was already skipped due to dependency error.
      return true
    }
    complete <- true
    traverse (run.defaultOrder() -> AsyncRun<#id> process) {
      // Order matters here, due to short-circuiting.
      complete <- process.tryFinish() && complete
    }
  }

  collect (collector) {
    \ self `collector.include` blocking
  }

  get () {
    if (!`present` result) {
      traverse (deps.defaultOrder() -> AsyncValue<ErrorOr<Int>> dep) {
        scoped {
          ErrorOr<Int> status <- dep.get()
        } in if (status.isError() || status.getValue() != 0) {
          result <- status
          break
        }
      }
    }
    if (! `present` result) {
      result <- exec.get()
    }
    return `require` result
  }
}

define CommandBuilder {
  $ReadOnly[command,args]$

  @value String command
  @value [ReadAt<String>&Append<String>] args
  @value Int stdin
  @value Int stdout
  @value Int stderr

  for (command) {
    return CommandBuilder{ command, Vector<String>.new(), -1, -1, -1 }
  }

  append (arg) {
    return addArg(arg)
  }

  addArg (arg) {
    \ args.append(arg.formatted())
    return self
  }

  setStdin (stdin2) {
    stdin <- stdin2
    return self
  }

  setStdout (stdout2) {
    stdout <- stdout2
    return self
  }

  setStderr (stderr2) {
    stderr <- stderr2
    return self
  }

  build () {
    return Command.new(command,args,stdin,stdout,stderr)
  }
}
