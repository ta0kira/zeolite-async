define TopoSort {
  $ReadOnly[blocking,blockedBy,weights,idToNode]$

  @value KVReader<#id,[DefaultOrder<#id>&SetReader<#id>]> blocking
  @value KVReader<#id,DefaultOrder<#id>> blockedBy
  @value CategoricalReader<#id> weights
  @value KVReader<#id,#n> idToNode

  relationFrom (source) {
    SearchTree<#id,TreeSet<#id>> blocking,
    SearchTree<#id,TreeSet<#id>> blockedBy,
    SearchTree<#id,#n> idToNode,
    CategoricalTree<#id> weights <-
        RelationBuilder<#n,#id>.buildFrom(source)
    return TopoSort<#n,#id>{ blocking, blockedBy, weights, idToNode }
  }

  graphQueue (source,random) {
    return DependencyQueue:new(source,weights,blocking,blockedBy,idToNode,random)
  }

  isSorted (source) (result) {
    result <- true
    scoped {
      Int i <- 0
    } in while (i < source.size()-1) {
      $ReadOnly[i]$
      scoped {
        Int j <- i+1
      } in while (j < source.size()) {
        $ReadOnly[j]$
        if (source.readAt(j) `lessThan2` source.readAt(i)) {
          return false
        }
      } update {
        j <- j+1
      }
    } update {
      i <- i+1
    }
  }

  lessThan2 (x,y) {
    return x.getId() `lessThanId` y.getId()
  }

  @value lessThanId (#id,#id) -> (Bool)
  lessThanId (id1,id2) {
    scoped {
      optional SetReader<#id> after1 <- blocking.get(id1)
    } in if (! `present` after1) {
      return false
    } else {
      return require(after1).member(id2)
    }
  }
}

concrete RelationBuilder<#n,#id> {
  #id immutable
  #id defines LessThan<#id>
  #n requires GraphNode<#id>

  @type buildFrom (ReadAt<#n>) -> (SearchTree<#id,TreeSet<#id>>,SearchTree<#id,TreeSet<#id>>,
                                   SearchTree<#id,#n>,CategoricalTree<#id>)
}

define RelationBuilder {
  @value SearchTree<#id,TreeSet<#id>> blocking
  @value SearchTree<#id,TreeSet<#id>> blockedBy
  @value SearchTree<#id,#n> idToNode
  @value CategoricalTree<#id> weights

  buildFrom (source) {
    return #self{
        SearchTree<#id,TreeSet<#id>>.new(),
        SearchTree<#id,TreeSet<#id>>.new(),
        SearchTree<#id,#n>.new(),
        CategoricalTree<#id>.new() }.process(source)
  }

  @value process (ReadAt<#n>) -> (SearchTree<#id,TreeSet<#id>>,SearchTree<#id,TreeSet<#id>>,
                                  SearchTree<#id,#n>,CategoricalTree<#id>)
  process (source) (blocking2,blockedBy2,idToNode2,weights2) {
    blocking2 <- blocking
    blockedBy2 <- blockedBy
    weights2 <- weights
    idToNode2 <- idToNode
    $Hidden[blocking2,blockedBy2,weights2,idToNode2]$
    \ collectNodes(source)
    traverse (idToNode.defaultOrder() -> KeyValue<#id,#n> idNode) {
      \ weights.incrWeight(idNode.getKey())
      \ idNode.getKey() `setBlockedBy` idNode.getValue().outgoing()
    }
  }

  @value collectNodes (ReadAt<#n>) -> ()
  collectNodes (nodes) {
    traverse (`ReadAtH:forwardOrder` nodes -> #n node) {
      #id id <- node.getId()
      if (! `present` idToNode.get(id)) {
        \ id `idToNode.set` node
        \ collectNodes(node.outgoing())
      }
    }
  }

  @value setBlockedBy (#id,ReadAt<#n>) -> ()
  setBlockedBy (id1,blockers) {
    traverse (`ReadAtH:forwardOrder` blockers -> #n node2) {
      #id id2 <- node2.getId()
      $ReadOnly[node2,id2]$
      TreeSet<#id> blockedByNode2 <- defer
      scoped {
        optional TreeSet<#id> existing <- blocking.get(id2)
      } in if (`present` existing) {
        blockedByNode2 <- `require` existing
      } else {
        \ id2 `blocking.set` (blockedByNode2 <- TreeSet<#id>.new())
      }
      $Hidden[blocking]$
      if (!blockedByNode2.member(id1)) {
        \ blockedByNode2.add(id1)
        $Hidden[blockedByNode2]$
        \ weights.incrWeight(id2)
        TreeSet<#id> blockingNode1 <- defer
        scoped {
          optional TreeSet<#id> existing <- blockedBy.get(id1)
        } in if (`present` existing) {
          blockingNode1 <- `require` existing
        } else {
          \ id1 `blockedBy.set` (blockingNode1 <- TreeSet<#id>.new())
        }
        \ blockingNode1.add(id2)
        \ id1 `setBlockedBy` node2.outgoing()
      }
    }
  }
}

concrete DependencyQueue<#n,#id> {
  #n requires GraphNode<#id>

  @category new<#n,#id>
    #id immutable
    #id defines LessThan<#id>
    #n requires GraphNode<#id>
  (ReadAt<#id>,                      // source
   CategoricalReader<#id>,           // priority
   KVReader<#id,DefaultOrder<#id>>,  // blocking
   KVReader<#id,DefaultOrder<#id>>,  // blockedBy
   KVReader<#id,#n>,                 // idToNode
   Generator<Float>)                 // random
  ->
  (BlockingGraphQueue<#n>)
}

define DependencyQueue {
  $ReadOnly[condition,priority,pending,generator,idToNode,blocking,blockedBy]$

  refines BlockingGraphQueue<#n>

  @value [ConditionWait&ConditionResume] condition

  @value CategoricalReader<#id> priority
  @value CategoricalTree<#id>   pending
  @value RandomCategorical<#id> generator

  @value SearchTree<#id,#n>              idToNode
  @value KVReader<#id,DefaultOrder<#id>> blocking
  @value SearchTree<#id,TreeSet<#id>>    blockedBy

  new (source,priority,blocking,blockedBy0,idToNode0,random) {
    CategoricalTree<#id>         pending   <- CategoricalTree<#id>.new()
    SearchTree<#id,#n>           idToNode  <- SearchTree<#id,#n>.new()
    SearchTree<#id,TreeSet<#id>> blockedBy <- SearchTree<#id,TreeSet<#id>>.new()

    traverse (`ReadAtH:forwardOrder` source -> #id id1) {
      \ id1 `idToNode.set` `require` `idToNode0.get` id1
      scoped {
        optional DefaultOrder<#id> blockingNode1 <- blockedBy0.get(id1)
      } in if (`present` blockingNode1) {
        \ id1 `blockedBy.set` (require(blockingNode1).defaultOrder() `OrderH:copyTo` TreeSet<#id>.new())
        $Hidden[id1]$
        traverse (require(blockingNode1).defaultOrder() -> #id id2) {
          $Hidden[blockingNode1]$
          if (! `present` idToNode.get(id2)) {
            \ id2 `idToNode.set` `require` `idToNode0.get` id2
            scoped {
              optional DefaultOrder<#id> blockingNode2 <- blockedBy0.get(id2)
            } in if (`present` blockingNode2) {
              \ id2 `blockedBy.set` (require(blockingNode2).defaultOrder() `OrderH:copyTo` TreeSet<#id>.new())
            }
          }
        }
      }
    }

    traverse (idToNode.defaultOrder() -> KeyValue<#id,any> idNode) {
      scoped {
        optional Container blockingNode <- blockedBy.get(idNode.getKey())
      } in if (! `present` blockingNode || require(blockingNode).size() == 0) {
        \ idNode.getKey() `pending.setWeight` `priority.getWeight` idNode.getKey()
      }
    }

    DependencyQueue<#n,#id> queue <- DependencyQueue<#n,#id>{
        ThreadCondition.new(),
        priority,
        pending,
        pending `RandomCategorical:sampleWith` random,
        idToNode,
        blocking,
        blockedBy }

    if (queue.shouldBlock()) {
      fail("DependencyQueue will never return a node")
    } else {
      return queue
    }
  }

  isEmpty () {
    scoped {
      MutexLock lock <- MutexLock.lock(condition)
      $Hidden[condition]$
    } cleanup {
      \ lock.freeResource()
    } in return idToNode.size() == 0
  }

  finish (complete) {
    scoped {
      MutexLock lock <- MutexLock.lock(condition)
      $Hidden[condition]$
    } cleanup {
      \ lock.freeResource()
    } in {
      if (`present` complete) {
        \ markComplete(require(complete).getId())
      }
    }
  }

  exchange (complete) {
    return exchangeCommon(complete,empty)
  }

  timedExchange (complete,timeout) {
    return exchangeCommon(complete,timeout)
  }

  @value exchangeCommon (optional #n,optional Float) -> (optional #n)
  exchangeCommon (complete,timeout) {
    scoped {
      MutexLock lock <- MutexLock.lock(condition)
    } cleanup {
      \ lock.freeResource()
    } in {
      if (`present` complete) {
        \ markComplete(require(complete).getId())
      }
      while (shouldBlock()) {
        if (`present` timeout) {
          if (!condition.timedWait(`require` timeout)) {
            break
          }
        } else {
          \ condition.wait()
        }
      }
      if (generator.isEmpty()) {
        return empty
      } else {
        #id id <- generator.generate()
        return idToNode.get(id)
      }
    }
  }

  @value shouldBlock () -> (Bool)
  shouldBlock () {
    return generator.isEmpty() && idToNode.size() > 0
  }

  @value markComplete (#id) -> ()
  markComplete (id1) {
    \ idToNode.remove(id1)
    \ id1 `pending.setWeight` 0
    scoped {
      optional DefaultOrder<#id> blockedByNode1 <- blocking.get(id1)
    } in if (`present` blockedByNode1) {
      traverse (require(blockedByNode1).defaultOrder() -> #id id2) {
        scoped {
          optional TreeSet<#id> blockingNode2 <- blockedBy.get(id2)
        } in if (`present` blockingNode2 && require(blockingNode2).remove(id1).size() == 0) {
          $Hidden[id1]$
          \ id2 `pending.setWeight` `priority.getWeight` id2
        }
      }
    }
    if (!shouldBlock()) {
      \ condition.resumeAll()
    }
  }
}
