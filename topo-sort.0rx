define TopoSort {
  $ReadOnly[blocking,weights]$

  @value KVReader<#id,[DefaultOrder<#id>&SetReader<#id>]> blocking
  @value CategoricalReader<#id> weights

  relationFrom (source) {
    SearchTree<#id,TreeSet<#id>> blocking, CategoricalTree<#id> weights <-
        RelationBuilder<#n,#id>.buildFrom(source)
    return TopoSort<#n,#id>{ blocking, weights }
  }

  graphQueue (source,random) {
    return DependencyQueue:new(source,weights,blocking,random)
  }

  isSorted (source) (result) {
    result <- true
    scoped {
      Int i <- 0
    } in while (i < source.size()-1) {
      $ReadOnly[i]$
      scoped {
        Int j <- i+1
      } in while (j < source.size()) {
        $ReadOnly[j]$
        if (source.readAt(j) `lessThan2` source.readAt(i)) {
          return false
        }
      } update {
        j <- j+1
      }
    } update {
      i <- i+1
    }
  }

  lessThan2 (x,y) {
    return x.getId() `lessThanId` y.getId()
  }

  @value lessThanId (#id,#id) -> (Bool)
  lessThanId (id1,id2) {
    scoped {
      optional SetReader<#id> after1 <- blocking.get(id1)
    } in if (! `present` after1) {
      return false
    } else {
      return require(after1).member(id2)
    }
  }
}

concrete RelationBuilder<#n,#id> {
  #id immutable
  #id defines LessThan<#id>
  #n requires GraphNode<#id>

  @type buildFrom (ReadAt<#n>) -> (SearchTree<#id,TreeSet<#id>>,CategoricalTree<#id>)
}

define RelationBuilder {
  @value SearchTree<#id,TreeSet<#id>> blocking
  @value CategoricalTree<#id> weights
  @value SearchTree<#id,#n> idToNode

  buildFrom (source) {
    return #self{
        SearchTree<#id,TreeSet<#id>>.new(),
        CategoricalTree<#id>.new(),
        SearchTree<#id,#n>.new() }.process(source)
  }

  @value process (ReadAt<#n>) -> (SearchTree<#id,TreeSet<#id>>,CategoricalTree<#id>)
  process (source) (blocking2,weights2) {
    blocking2 <- blocking
    weights2 <- weights
    $Hidden[blocking2,weights2]$
    \ collectNodes(source)
    traverse (idToNode.defaultOrder() -> KeyValue<#id,#n> idNode) {
      \ weights.incrWeight(idNode.getKey())
      \ idNode.getKey() `setBlockedBy` idNode.getValue().outgoing()
    }
  }

  @value collectNodes (ReadAt<#n>) -> ()
  collectNodes (nodes) {
    traverse (`ReadAtH:forwardOrder` nodes -> #n node) {
      #id id <- node.getId()
      if (! `present` idToNode.get(id)) {
        \ id `idToNode.set` node
        \ collectNodes(node.outgoing())
      }
    }
  }

  @value setBlockedBy (#id,ReadAt<#n>) -> ()
  setBlockedBy (id1,blockedBy) {
    traverse (`ReadAtH:forwardOrder` blockedBy -> #n node2) {
      #id id2 <- node2.getId()
      $ReadOnly[node2,id2]$
      TreeSet<#id> blockedByNode2 <- defer
      scoped {
        optional TreeSet<#id> existing <- blocking.get(id2)
      } in if (`present` existing) {
        blockedByNode2 <- `require` existing
      } else {
        \ id2 `blocking.set` (blockedByNode2 <- TreeSet<#id>.new())
      }
      if (!blockedByNode2.member(id1)) {
        \ blockedByNode2.add(id1)
        \ weights.incrWeight(id2)
        \ id1 `setBlockedBy` node2.outgoing()
      }
    }
  }
}

concrete DependencyQueue<#n,#id> {
  #n requires GraphNode<#id>

  @category new<#n,#id>
    #id immutable
    #id defines LessThan<#id>
    #n requires GraphNode<#id>
  (ReadAt<#n>,CategoricalReader<#id>,KVReader<#id,DefaultOrder<#id>>,Generator<Float>) -> (GraphQueue<#n>)
}

define DependencyQueue {
  $ReadOnly[condition,priority,pending,generator,idToNode,blocking,blockedBy]$

  refines GraphQueue<#n>

  @value [ConditionWait&ConditionResume] condition

  @value CategoricalReader<#id> priority
  @value CategoricalTree<#id>   pending
  @value RandomCategorical<#id> generator

  @value SearchTree<#id,#n>              idToNode
  @value KVReader<#id,DefaultOrder<#id>> blocking
  @value SearchTree<#id,TreeSet<#id>>    blockedBy

  new (source,priority,blocking,random) {
    CategoricalTree<#id>         pending   <- CategoricalTree<#id>.new()
    SearchTree<#id,#n>           idToNode  <- SearchTree<#id,#n>.new()
    SearchTree<#id,TreeSet<#id>> blockedBy <- SearchTree<#id,TreeSet<#id>>.new()

    traverse (`ReadAtH:forwardOrder` source -> #n node) {
      #id id <- node.getId()
      if (priority.getWeight(id) == 0) {
        fail("node with 0 priority will never be returned")
      } else {
        \ node.getId() `idToNode.set` node
      }
    }

    traverse (`ReadAtH:forwardOrder` source -> #n node1) {
      #id id1 <- node1.getId()
      $ReadOnly[node1]$
      TreeSet<#id> blockingNode1 <- TreeSet<#id>.new()
      $ReadOnly[id1]$
      traverse (`ReadAtH:forwardOrder` node1.outgoing() -> #n node2) {
        #id id2 <- node2.getId()
        $Hidden[node1,node2]$
        if (`present` idToNode.get(id2)) {
          \ blockingNode1.add(id2)
        }
      }
      $Hidden[node1]$
      if (blockingNode1.size() > 0) {
        \ id1 `blockedBy.set` blockingNode1
      } else {
        \ id1 `pending.setWeight` `priority.getWeight` id1
      }
    }

    DependencyQueue<#n,#id> queue <- DependencyQueue<#n,#id>{
        ThreadCondition.new(),
        priority,
        pending,
        pending `RandomCategorical:sampleWith` random,
        idToNode,
        blocking,
        blockedBy }

    if (queue.shouldBlock()) {
      fail("DependencyQueue will never return a node")
    } else {
      return queue
    }
  }

  isEmpty () {
    scoped {
      MutexLock lock <- MutexLock.lock(condition)
      $Hidden[condition]$
    } cleanup {
      \ lock.freeResource()
    } in return idToNode.size() == 0
  }

  finish (complete) {
    scoped {
      MutexLock lock <- MutexLock.lock(condition)
      $Hidden[condition]$
    } cleanup {
      \ lock.freeResource()
    } in {
      if (`present` complete) {
        \ markComplete(require(complete).getId())
      }
    }
  }

  exchange (complete) {
    scoped {
      MutexLock lock <- MutexLock.lock(condition)
    } cleanup {
      \ lock.freeResource()
    } in {
      if (`present` complete) {
        \ markComplete(require(complete).getId())
      }
      while (shouldBlock()) {
        \ condition.wait()
      }
      if (generator.isEmpty()) {
        return empty
      } else {
        #id id <- generator.generate()
        return idToNode.get(id)
      }
    }
  }

  @value shouldBlock () -> (Bool)
  shouldBlock () {
    return generator.isEmpty() && idToNode.size() > 0
  }

  @value markComplete (#id) -> ()
  markComplete (id1) {
    \ idToNode.remove(id1)
    \ id1 `pending.setWeight` 0
    scoped {
      optional DefaultOrder<#id> blockedByNode1 <- blocking.get(id1)
    } in if (`present` blockedByNode1) {
      traverse (require(blockedByNode1).defaultOrder() -> #id id2) {
        scoped {
          optional TreeSet<#id> blockingNode2 <- blockedBy.get(id2)
        } in if (`present` blockingNode2 && require(blockingNode2).remove(id1).size() == 0) {
          $Hidden[id1]$
          Int weight <- `priority.getWeight` id2
          if (weight > 0) {
            \ id2 `pending.setWeight` weight
          } else {
            fail("node with 0 priority will never be returned")
          }
        }
      }
    }
    if (!shouldBlock()) {
      \ condition.resumeAll()
    }
  }
}
