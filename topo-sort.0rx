define TopoSort {
  $ReadOnly[reachableFrom,weights]$

  refines LessThan2<#n>

  @value KVReader<#id,[DefaultOrder<#id>&SetReader<#id>]> reachableFrom
  @value CategoricalReader<#id> weights

  relationFrom (source) {
    SearchTree<#id,TreeSet<#id>> reachableFrom, CategoricalTree<#id> weights <-
        RelationBuilder<#n,#id>.buildFrom(source)
    return TopoSort<#n,#id>{ reachableFrom, weights }
  }

  graphQueue (source,random) {
    return DependencyQueue:new(source,weights,reachableFrom,random)
  }

  isSorted (source) (result) {
    result <- true
    scoped {
      Int i <- 0
    } in while (i < source.size()-1) {
      $ReadOnly[i]$
      scoped {
        Int j <- i+1
      } in while (j < source.size()) {
        $ReadOnly[j]$
        if (source.readAt(j) `lessThan2` source.readAt(i)) {
          return false
        }
      } update {
        j <- j+1
      }
    } update {
      i <- i+1
    }
  }

  lessThan2 (x,y) {
    return x.getId() `lessThanId` y.getId()
  }

  @value lessThanId (#id,#id) -> (Bool)
  lessThanId (id1,id2) {
    scoped {
      optional SetReader<#id> after1 <- reachableFrom.get(id1)
    } in if (! `present` after1) {
      return false
    } else {
      return require(after1).member(id2)
    }
  }
}

concrete RelationBuilder<#n,#id> {
  #id immutable
  #id defines LessThan<#id>
  #n requires GraphNode<#id>

  @type buildFrom (ReadAt<#n>) -> (SearchTree<#id,TreeSet<#id>>,CategoricalTree<#id>)
}

define RelationBuilder {
  $ReadOnly[reachableFrom,weights]$

  @value SearchTree<#id,TreeSet<#id>> reachableFrom
  @value CategoricalTree<#id> weights

  buildFrom (source) {
    return #self{ SearchTree<#id,TreeSet<#id>>.new(), CategoricalTree<#id>.new() }.populate(TreeSet<#id>.new(),source).get()
  }

  @value populate (TreeSet<#id>,ReadAt<#n>) -> (#self)
  populate (from,to) {
    traverse (`ReadAtH:forwardOrder` to -> #n node) {
      $Hidden[to]$
      #id id <- node.getId()
      $ReadOnly[node,id]$
      if (from.member(id)) {
        fail("graph cycle detected")
      }
      if (! `present` reachableFrom.get(id)) {
        \ id `reachableFrom.set` TreeSet<#id>.new()
      }
      if (`weights.getWeight` id == 0) {
        \ id `weights.setWeight` 1
      }
      TreeSet<#id> nodes <- `require` reachableFrom.get(id)
      traverse (from.defaultOrder() -> #id id2) {
        if (!nodes.member(id2)) {
          \ nodes.add(id2)
          \ weights.incrWeight(id)
        }
      }
      \ from.add(id)
      \ populate(from,node.outgoing())
      \ from.remove(id)
    }
    return self
  }

  @value get () -> (SearchTree<#id,TreeSet<#id>>,CategoricalTree<#id>)
  get () {
    return reachableFrom, weights
  }
}

concrete DependencyQueue<#n,#id> {
  #n requires GraphNode<#id>

  @category new<#n,#id>
    #id immutable
    #id defines LessThan<#id>
    #n requires GraphNode<#id>
  (ReadAt<#n>,CategoricalReader<#id>,KVReader<#id,DefaultOrder<#id>>,Generator<Float>) -> (GraphQueue<#n>)
}

define DependencyQueue {
  $ReadOnly[mutex,priority,pending,generator,idToNode,blocking,blockedBy]$

  refines GraphQueue<#n>

  @value Mutex mutex

  @value CategoricalReader<#id> priority
  @value CategoricalTree<#id>   pending
  @value RandomCategorical<#id> generator

  @value KVReader<#id,#n>                idToNode
  @value KVReader<#id,DefaultOrder<#id>> blocking
  @value SearchTree<#id,TreeSet<#id>>    blockedBy

  new (source,priority,blocking,random) {
    CategoricalTree<#id>         pending   <- CategoricalTree<#id>.new()
    SearchTree<#id,#n>           idToNode  <- SearchTree<#id,#n>.new()
    SearchTree<#id,TreeSet<#id>> blockedBy <- SearchTree<#id,TreeSet<#id>>.new()

    traverse (`ReadAtH:forwardOrder` source -> #n node) {
      \ node.getId() `idToNode.set` node
    }

    traverse (`ReadAtH:forwardOrder` source -> #n node1) {
      #id id1 <- node1.getId()
      $ReadOnly[node1]$
      TreeSet<#id> blockingNode1 <- TreeSet<#id>.new()
      $ReadOnly[id1]$
      traverse (`ReadAtH:forwardOrder` node1.outgoing() -> #n node2) {
        #id id2 <- node2.getId()
        $Hidden[node1,node2]$
        if (`present` idToNode.get(id2)) {
          \ blockingNode1.add(id2)
        }
      }
      $Hidden[node1]$
      if (blockingNode1.size() > 0) {
        \ id1 `blockedBy.set` blockingNode1
      } else {
        \ id1 `pending.setWeight` `priority.getWeight` id1
      }
    }

    return DependencyQueue<#n,#id>{
        SimpleMutex.new(),
        priority,
        pending,
        pending `RandomCategorical:sampleWith` random,
        idToNode,
        blocking,
        blockedBy }
  }

  exchange (complete) {
    scoped {
      MutexLock lock <- MutexLock.lock(mutex)
    } cleanup {
      \ lock.freeResource()
    } in {
      if (`present` complete) {
        \ markComplete(require(complete).getId())
      }
      if (generator.isEmpty()) {
        // TODO: If there are multiple threads, this might not actually indicate
        // that there are no more nodes to process.
        return empty
      } else {
        #id id <- generator.generate()
        return idToNode.get(id)
      }
    }
  }

  @value markComplete (#id) -> ()
  markComplete (id) {
    \ id `pending.setWeight` 0
    scoped {
      optional DefaultOrder<#id> blockedByNode1 <- blocking.get(id)
    } in if (`present` blockedByNode1) {
      traverse (require(blockedByNode1).defaultOrder() -> #id id2) {
        scoped {
          optional TreeSet<#id> blockingNode2 <- blockedBy.get(id2)
        } in if (`present` blockingNode2 && require(blockingNode2).remove(id).size() == 0) {
          $Hidden[id]$
          Int weight <- `priority.getWeight` id2
          if (weight > 0) {
            \ id2 `pending.setWeight` weight
          } else {
            // TODO: Should there be a default or error instead? In case the
            // caller forgot to include the node in the priorities.
            \ markComplete(id2)
          }
        }
      }
    }
  }
}
