define TopoSort {
  $ReadOnly[reachableFrom,weights]$

  refines LessThan2<#n>

  @value KVReader<#id,[DefaultOrder<#id>&SetReader<#id>]> reachableFrom
  @value CategoricalReader<#id> weights

  relationFrom (source) {
    SearchTree<#id,TreeSet<#id>> reachableFrom, CategoricalTree<#id> weights <-
        RelationBuilder<#n,#id>.buildFrom(source)
    return TopoSort<#n,#id>{ reachableFrom, weights }
  }

  fastRandom (source,random) {
    [Append<#n>&ReadAt<#n>] randomized <- Vector<#n>.new()

    CategoricalTree<#id>   pending   <- CategoricalTree<#id>.new()
    RandomCategorical<#id> generator <- pending `RandomCategorical:sampleWith` random

    SearchTree<#id,#n>           idToNode  <- SearchTree<#id,#n>.new()
    SearchTree<#id,TreeSet<#id>> blocking  <- SearchTree<#id,TreeSet<#id>>.new()
    SearchTree<#id,TreeSet<#id>> blockedBy <- SearchTree<#id,TreeSet<#id>>.new()

    $ReadOnly[randomized,pending,generator,idToNode,blocking,blockedBy]$

    // Initialize data structures.
    traverse (`ReadAtH:forwardOrder` source -> #n node) {
      $Hidden[source]$
      #id id <- node.getId()
      $ReadOnly[node,id]$
      \ id `idToNode.set`  node
      \ id `blocking.set`  TreeSet<#id>.new()
      \ id `blockedBy.set` TreeSet<#id>.new()
    }
    traverse (`ReadAtH:forwardOrder` source -> #n node) {
      $Hidden[source]$
      #id id1 <- node.getId()
      $Hidden[node]$
      $ReadOnly[id1]$
      traverse (require(reachableFrom.get(id1)).defaultOrder() -> #id id2) {
        $ReadOnly[id2]$
        if (`present` idToNode.get(id2)) {
          // Only use id2 if it's included in the source.
          \ require(blockedBy.get(id2)).add(id1)
          \ require(blocking.get(id1)).add(id2)
        }
      }
    }
    traverse (blockedBy.defaultOrder() -> KeyValue<#id,Container> maybeBlocked) {
      if (maybeBlocked.getValue().size() == 0) {
        \ maybeBlocked.getKey() `pending.setWeight` `weights.getWeight` maybeBlocked.getKey()
      }
    }
    if (idToNode.size() != source.size()) {
      fail("duplicate node key detected")
    }

    // Generate traversal order.
    while (!generator.isEmpty()) {
      #id id <- generator.generate()
      \ id `pending.setWeight` 0
      \ randomized.append(`require` idToNode.get(id))
      traverse (require(blocking.get(id)).defaultOrder() -> #id id2) {
        if (require(blockedBy.get(id2)).remove(id).size() == 0) {
          $Hidden[id]$
          \ id2 `pending.setWeight` `weights.getWeight` id2
        }
      }
      \ blocking.remove(id)
    }

    // Transpose results.
    if (randomized.size() != source.size()) {
      fail("algorithm failure")
    }
    traverse (`Counter.zeroIndexed` randomized.size() -> Int i) {
      \ source.writeAt(i,randomized.readAt(i))
    }
  }

  isSorted (source) (result) {
    result <- true
    scoped {
      Int i <- 0
    } in while (i < source.size()-1) {
      $ReadOnly[i]$
      scoped {
        Int j <- i+1
      } in while (j < source.size()) {
        $ReadOnly[j]$
        if (source.readAt(j) `lessThan2` source.readAt(i)) {
          return false
        }
      } update {
        j <- j+1
      }
    } update {
      i <- i+1
    }
  }

  lessThan2 (x,y) {
    return x.getId() `lessThanId` y.getId()
  }

  @value lessThanId (#id,#id) -> (Bool)
  lessThanId (id1,id2) {
    scoped {
      optional SetReader<#id> after1 <- reachableFrom.get(id1)
    } in if (! `present` after1) {
      return false
    } else {
      return require(after1).member(id2)
    }
  }
}

concrete RelationBuilder<#n,#id> {
  #id immutable
  #id defines LessThan<#id>
  #n requires GraphNode<#id>

  @type buildFrom (ReadAt<#n>) -> (SearchTree<#id,TreeSet<#id>>,CategoricalTree<#id>)
}

define RelationBuilder {
  $ReadOnly[reachableFrom,weights]$

  @value SearchTree<#id,TreeSet<#id>> reachableFrom
  @value CategoricalTree<#id> weights

  buildFrom (source) {
    return #self{ SearchTree<#id,TreeSet<#id>>.new(), CategoricalTree<#id>.new() }.populate(TreeSet<#id>.new(),source).get()
  }

  @value populate (TreeSet<#id>,ReadAt<#n>) -> (#self)
  populate (from,to) {
    traverse (`ReadAtH:forwardOrder` to -> #n node) {
      $Hidden[to]$
      #id id <- node.getId()
      $ReadOnly[node,id]$
      if (from.member(id)) {
        fail("graph cycle detected")
      }
      if (! `present` reachableFrom.get(id)) {
        \ id `reachableFrom.set` TreeSet<#id>.new()
      }
      if (`weights.getWeight` id == 0) {
        \ id `weights.setWeight` 1
      }
      TreeSet<#id> nodes <- `require` reachableFrom.get(id)
      traverse (from.defaultOrder() -> #id id2) {
        if (!nodes.member(id2)) {
          \ nodes.add(id2)
          \ weights.incrWeight(id)
        }
      }
      \ from.add(id)
      \ populate(from,node.outgoing())
      \ from.remove(id)
    }
    return self
  }

  @value get () -> (SearchTree<#id,TreeSet<#id>>,CategoricalTree<#id>)
  get () {
    return reachableFrom, weights
  }
}
